# Overview

**Project name:** **ClusterKit** — a single GKE Autopilot cluster hosting many side-projects and domains behind Cloudflare with scale-to-zero capabilities.

**Problem:** Makers juggle multiple small apps across hosts and tangled DNS/TLS. Infra busywork slows shipping, and idle apps burn money.

**Who it's for:** Solo builders/indie teams who want one reliable, ultra-low-cost home for many low-traffic personal projects.

**Why it's valuable:** One cluster, many projects: Knative scale-to-zero, automatic DNS + TLS, sane defaults, per-project isolation, and deploy a new app in 10 minutes. Pay only for what you use.

# Core Features

1. **Knative Serverless Apps**

* **What:** Deploy apps that scale to zero when idle, wake up automatically on request.
* **Why:** Dramatic cost savings for low-traffic projects (60-80% cheaper). No manual HPA configuration.
* **How:** `clusterkit create blog --domain blog.example.com` → Knative Service with auto DNS + TLS + scale-to-zero.

2. **Multi-Domain Routing**

* **What:** One ingress + ExternalDNS + cert-manager to serve many apex/subdomains.
* **Why:** Add domains fast; keep infra simple and cheap.
* **How:** Knative integrates with nginx Ingress + ExternalDNS (Cloudflare provider) + cert-manager for automatic TLS.

3. **TLS Automation**

* **What:** Let's Encrypt HTTP-01 certificates via cert-manager, fully automatic.
* **Why:** Zero-touch certificate lifecycle for all domains.
* **How:** cert-manager ClusterIssuer + Knative auto-creates Certificate CRs per domain.

4. **Cloudflare Edge Enhancements**

* **What:** CDN/WAF/caching/rate-limit at the edge, zero app-code changes.
* **Why:** Faster global delivery, security, and edge caching masks cold-start latency.
* **How:** Orange-cloud proxied A/AAAA to GCP LB IP, `CF-Connecting-IP` honored in ingress.

5. **In-Cluster Databases**

* **What:** PostgreSQL StatefulSets with persistent volumes and automatic backups.
* **Why:** Cheaper than Cloud SQL for low-traffic use; provides full control over database configuration.
* **How:** `clusterkit db create mydb --engine postgres` → StatefulSet + PVC + Secret with connection string.

6. **Observability Baseline**

* **What:** GCP Cloud Monitoring and Logging (free tier), basic uptime checks.
* **Why:** See health and costs without running Prometheus/Grafana in-cluster.
* **How:** GKE native integration with automatic metrics collection and log aggregation.

7. **GKE Autopilot Cost Optimization**

* **What:** Google manages nodes, you pay per pod. Autopilot right-sizes resources automatically.
* **Why:** No node pool management, no cluster autoscaler config, predictable pricing.
* **How:** Autopilot mode + tight resource requests on pods + Knative scale-to-zero.

# User Experience

**Personas**

* *Solo Builder "Prass"*: wants to deploy a new idea in 10 minutes, forget about it, pay almost nothing if it's idle.
* *Tinkerer*: runs small cron/API services, needs TLS + DNS without yak-shaving, wants to experiment without cost anxiety.

**Key Flows**

1. **Create serverless app** → `clusterkit create blog --domain blog.prass.dev` → Knative Service deployed, DNS updated, TLS issued, scales to zero when idle.
2. **Add database** → `clusterkit db create blogdb --attach blog` → PostgreSQL StatefulSet + Secret, auto-wired to app.
3. **Add another domain** → `clusterkit domain add blog landing.prass.dev` → DNS + TLS automatically updated.
4. **Check status** → `clusterkit status blog` → Shows URL, cert status, current scale (0 or N pods), last traffic, resource usage.
5. **Deploy always-on service** → `clusterkit create api --min-scale 1` → Knative Service with min 1 replica (websockets, realtime APIs).

**UX Considerations**

* Plain-English `clusterkit` CLI with dry-run mode and helpful defaults.
* Knative by default; `--traditional` flag for standard Deployments when required for always-on workloads.
* Clear feedback: "App scaled to zero (saving $X/month)" vs "App always-on (costs $Y/month)".
* Smart templates: static sites default to scale-to-zero, APIs with websockets default to min-scale=1.

# Technical Architecture  

**System Components**

* **GKE Autopilot** — Google-managed nodes, pay-per-pod pricing, no cluster autoscaler needed.
* **Knative Serving** — Serverless platform with scale-to-zero, request-driven autoscaling, traffic splitting.
* **Ingress** — NGINX Ingress Controller (Knative networking layer), single `LoadBalancer` Service.
* **DNS** — ExternalDNS (Cloudflare provider), watches Knative Services and Ingress resources.
* **TLS** — cert-manager + Let's Encrypt HTTP-01, auto-provisions certs for Knative Services.
* **CDN/WAF** — Cloudflare proxy enabled for all public domains.
* **Databases** — PostgreSQL/MySQL as StatefulSets with persistent GCP disks, automated backups via snapshots.
* **Secrets** — Kubernetes Secrets with RBAC for MVP; External Secrets integration in Phase 4 for GitOps workflows.
* **Observability** — GCP Cloud Monitoring + Cloud Logging (native GKE integration).

**Data Models**

* **App** (namespace) → owns Knative Services (or traditional Deployments), ResourceQuota, NetworkPolicy.
* **Knative Service** → owns RevisionTemplate (pod spec), auto-creates Route + Configuration + Revisions.
* **Domain** → mapped to Knative Service or Ingress; cert-manager Certificate CR per domain.
* **Database** — StatefulSet (1 replica for dev) + PVC + Secret (connection URL) + ConfigMap for migration tracking.

**APIs & Integrations**

* **Cloudflare API** — DNS record management via ExternalDNS.
* **ACME (Let's Encrypt)** — Certificate issuance via cert-manager.
* **GCP APIs** — GKE, Compute (for LB IP), Cloud Monitoring/Logging.

**Infrastructure Requirements**

* GCP project with GKE Autopilot enabled.
* Service accounts: ExternalDNS (Cloudflare API token), cert-manager (ACME account).
* One static IP for ingress LoadBalancer.
* Autopilot handles node sizing automatically.

# Development Roadmap  

**MVP (Foundation) — Ship in Days**

* Terraform: GKE Autopilot cluster, static IP for LoadBalancer, IAM service accounts.
* Helm/YAML: Knative Serving + nginx ingress, cert-manager (ClusterIssuer LE HTTP-01), ExternalDNS (Cloudflare).
* `clusterkit` CLI (Go or Python):
  * `clusterkit bootstrap` — provisions cluster + core components.
  * `clusterkit create <name> --domain <host>` — deploys Knative Service with DNS + TLS.
  * `clusterkit status <name>` — shows app status, scale, cert.
* One sample app deployed (static site or simple API) to validate end-to-end flow.
* Documentation: Cloudflare setup, GKE Autopilot benefits, troubleshooting cold starts.

**Phase 2 (Databases & Flexibility) — Add Persistence**

* In-cluster PostgreSQL StatefulSet with PVC + automated backups (GCP disk snapshots).
* `clusterkit db create <name>` — provisions DB + secrets.
* `clusterkit db attach <app> <db>` — injects connection secret into app.
* Support for `--traditional` deployment mode (standard Deployment + Service + Ingress) for always-on apps.
* `--min-scale N` flag for Knative apps that need warm replicas (websockets, low-latency APIs).

**Phase 3 (Multi-Domain & Refinement) — Scale Out**

* Wildcard domain support with DNS-01 challenge for Let's Encrypt.
* Second ExternalDNS instance with `--domain-filter` for managing multiple DNS providers.
* Rate-limiting and client IP forwarding (CF-Connecting-IP) for Cloudflare-proxied traffic.
* Basic cost tracking: show per-app resource usage and estimated monthly cost.
* MySQL StatefulSet support alongside PostgreSQL.

**Phase 4 (Power-User Features) — Polish**

* App templates: "Static site" (Nginx), "Node API", "Python API", "Cron worker" (CronJob, not Knative).
* Canary deployments: Knative traffic splitting for blue/green or gradual rollouts.
* Sealed Secrets integration for GitOps-friendly secret management.
* Simple web UI for non-CLI users: dashboard showing apps, domains, costs, scale status.
* PVC backup automation: scheduled snapshots with retention policies.

**Phase 5 (Production-Grade Scaling)**

* Cloud SQL migration path: `clusterkit db migrate <name> --to-cloudsql` for apps that outgrow in-cluster DBs.
* Custom metrics autoscaling: scale Knative services on queue depth, DB connections, etc.
* Multi-cluster support: run staging and prod in separate clusters.
* Integrated CI/CD helpers: GitHub Actions / GitLab CI snippets for `clusterkit deploy`.

# Logical Dependency Chain  

1. **GKE Autopilot + Static IP** → Cluster foundation, no node management.
2. **Knative Serving + nginx Ingress** → Serverless platform with HTTP routing.
3. **cert-manager + Let's Encrypt HTTP-01** → Automatic TLS for all domains.
4. **ExternalDNS (Cloudflare)** → Automatic DNS record creation. *(Now we can deploy a working app!)*
5. **`clusterkit` CLI scaffolding** → Create Knative Services, deploy sample app.
6. **In-cluster PostgreSQL** → Add persistence without Cloud SQL cost.
7. **Traditional deployment mode** → Support for always-on apps (websockets, etc).
8. **Cost tracking & optimization** → Show savings from scale-to-zero, resource hints.

# Risks and Mitigations  

* **Cold-start latency (2-5s)** → *Mitigate:* Cloudflare edge caching, `--min-scale 1` for latency-sensitive apps, warm-up probes.
* **Knative complexity for debugging** → *Mitigate:* Clear docs, `clusterkit logs <app>` helper, `kubectl` escape hatch always available.
* **Database performance in-cluster** → *Mitigate:* Start with StatefulSet, monitor IOPS/CPU, document Cloud SQL migration path.
* **Cloudflare caching breaking dynamic apps** → *Mitigate:* Cache rules per domain (static assets only), document bypass headers.
* **Autopilot resource constraints** → *Mitigate:* Set tight but realistic resource requests (e.g., 100m CPU, 128Mi), let Autopilot optimize.
* **Multiple DNS providers** → *Mitigate:* ExternalDNS `--domain-filter` per instance, clear naming conventions.
* **Lost client IP behind Cloudflare** → *Mitigate:* `CF-Connecting-IP` header + nginx `real-ip-header` annotation.

# Appendix  

**Reference Manifests (abridged)**

**Knative Service (Scale-to-Zero)**

```yaml
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: blog
  namespace: blog
spec:
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/min-scale: "0"
        autoscaling.knative.dev/max-scale: "5"
        autoscaling.knative.dev/target: "10"  # Requests per pod
    spec:
      containers:
      - image: ghcr.io/prass/blog:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: blog-db
              key: url
```

**Knative Service (Always-On)**

```yaml
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: realtime-api
spec:
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/min-scale: "1"  # Always at least 1 pod
        autoscaling.knative.dev/max-scale: "10"
    spec:
      containers:
      - image: ghcr.io/prass/realtime-api:latest
        ports:
        - containerPort: 8080
```

**ClusterIssuer (Let's Encrypt HTTP-01)**

```yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-http
spec:
  acme:
    email: ops@example.com
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef: { name: le-account-key }
    solvers:
    - http01:
        ingress:
          class: nginx
```

**ExternalDNS (Cloudflare) – key flags**

```yaml
args:
  - --source=service
  - --source=ingress
  - --source=knative  # Watch Knative Services
  - --provider=cloudflare
  - --policy=upsert-only
  - --domain-filter=prass.dev
  - --txt-owner-id=clusterkit
env:
  - name: CF_API_TOKEN
    valueFrom:
      secretKeyRef:
        name: cloudflare
        key: api-token
```

**PostgreSQL StatefulSet (Simplified)**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: blogdb
spec:
  serviceName: postgres
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:16-alpine
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_DB
          value: blog
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: postgres-creds
              key: username
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-creds
              key: password
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 1Gi
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 10Gi
```

**Terraform Module Structure**

* `terraform/gke/` → GKE Autopilot cluster, static IP, IAM service accounts.
* `terraform/db-statefulset/` → Helm-based PostgreSQL/MySQL StatefulSet + PVC + Secrets.
* `terraform/cloudflare/` → Bootstrap DNS records for initial cluster setup before ExternalDNS takes over.

**CLI Command Reference**

```bash
# Bootstrap cluster
clusterkit bootstrap --cluster my-cluster --region us-central1

# Create scale-to-zero app
clusterkit create blog --domain blog.prass.dev --image ghcr.io/user/blog:latest

# Create always-on app
clusterkit create api --domain api.prass.dev --min-scale 1

# Create database
clusterkit db create blogdb --engine postgres --storage 10Gi

# Attach database to app
clusterkit db attach blog blogdb

# Add domain to existing app
clusterkit domain add blog www.prass.dev

# Check status
clusterkit status blog
# Output: 
# App: blog
# Domain: blog.prass.dev (✓ TLS valid)
# Status: Scaled to zero (last traffic: 2h ago)
# Estimated cost: $0.20/month (idle)

# View logs
clusterkit logs blog --tail 100

# Traditional deployment mode
clusterkit create legacy-app --traditional --replicas 2
```

**Cost Estimates (us-central1, approximate)**

| Configuration | Monthly Cost |
|---------------|--------------|
| 5 apps (scale-to-zero, idle) | $5-10 |
| 5 apps (low traffic, 1hr/day active) | $15-25 |
| 1 PostgreSQL (10GB, 256Mi RAM) | $8-12 |
| 1 always-on API (min-scale=1) | $10-15 |
| Static IP + LoadBalancer | $5-8 |
| **Total (typical)** | **$25-45/month** |

Compare to: Cloud Run ($20-40) + Cloud SQL ($25+) + per-project overhead = $60-100+.
