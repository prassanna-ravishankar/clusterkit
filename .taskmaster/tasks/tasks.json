{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Terraform Infrastructure Foundation",
        "description": "Create Terraform modules for GKE Autopilot cluster, static IP, and IAM service accounts",
        "details": "Create terraform/ directory structure with modules for: 1) terraform/gke/ - GKE Autopilot cluster configuration with latest Kubernetes version (1.28+), static external IP for LoadBalancer, IAM service accounts for ExternalDNS and cert-manager. 2) terraform/providers/ - Google Cloud Platform provider with required APIs (container.googleapis.com, compute.googleapis.com). Include variables.tf for project_id, region, cluster_name. Use google_container_cluster resource with mode='AUTOPILOT' and release_channel='REGULAR'.",
        "testStrategy": "Validate Terraform plan output, verify cluster creation with 'terraform apply', test kubectl connectivity to cluster",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create terraform directory structure and provider configuration",
            "description": "Initialize the terraform project structure with proper directory layout and configure the Google Cloud Platform provider with required API enablement",
            "dependencies": [],
            "details": "Create terraform/ root directory with subdirectories: terraform/modules/gke/, terraform/modules/networking/, terraform/providers/. Configure google provider in providers/main.tf with required APIs: container.googleapis.com, compute.googleapis.com, iam.googleapis.com. Set up provider version constraints and authentication configuration.",
            "status": "done",
            "testStrategy": "Validate terraform init runs successfully, verify provider configuration with terraform validate"
          },
          {
            "id": 2,
            "title": "Implement GKE Autopilot cluster module with required APIs",
            "description": "Create the core GKE Autopilot cluster module with proper configuration for Kubernetes 1.28+ and required Google Cloud APIs",
            "dependencies": [
              1
            ],
            "details": "Create terraform/modules/gke/main.tf with google_container_cluster resource configured for mode='AUTOPILOT' and release_channel='REGULAR'. Include kubernetes_version constraint for 1.28+. Configure cluster networking, node pools, and security settings. Enable required APIs through google_project_service resources.",
            "status": "done",
            "testStrategy": "Run terraform plan to validate cluster configuration, verify API enablement with gcloud services list"
          },
          {
            "id": 3,
            "title": "Configure static IP resource for LoadBalancer services",
            "description": "Create Google Cloud static IP address resource for LoadBalancer services and external access configuration",
            "dependencies": [
              1
            ],
            "details": "Create terraform/modules/networking/main.tf with google_compute_global_address resource for static external IP. Configure IP reservation for LoadBalancer services and ingress controllers. Include proper naming conventions and regional/global scope configuration.",
            "status": "done",
            "testStrategy": "Validate IP address reservation with terraform plan, test IP allocation and release with terraform apply/destroy"
          },
          {
            "id": 4,
            "title": "Create IAM service accounts for ExternalDNS and cert-manager",
            "description": "Set up dedicated Google Cloud IAM service accounts with proper roles and permissions for ExternalDNS and cert-manager operations",
            "dependencies": [
              2
            ],
            "details": "Create terraform/modules/iam/main.tf with google_service_account resources for external-dns and cert-manager. Configure IAM bindings: dns.admin role for ExternalDNS, secretmanager.secretAccessor for cert-manager. Generate and manage service account keys securely using google_service_account_key resource.",
            "status": "done",
            "testStrategy": "Verify service account creation and role assignments with gcloud iam service-accounts list, test permissions with gcloud auth"
          },
          {
            "id": 5,
            "title": "Add variables.tf and outputs.tf for proper parameterization",
            "description": "Create comprehensive variable definitions and output values for terraform modules to enable reusability and proper configuration management",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create variables.tf with required variables: project_id, region, cluster_name, kubernetes_version, static_ip_name. Include optional variables for cluster configuration. Create outputs.tf with cluster endpoint, static IP address, service account emails, and cluster credentials. Add validation rules and default values where appropriate.",
            "status": "done",
            "testStrategy": "Validate variable constraints with terraform validate, test outputs with terraform apply and verify accessible values"
          }
        ]
      },
      {
        "id": 2,
        "title": "Install Knative Serving Platform",
        "description": "Deploy Knative Serving v1.12+ with proper networking configuration for serverless workloads",
        "details": "Install Knative Serving using kubectl apply from official releases (v1.12.x stable). Configure networking layer with Kourier or nginx ingress controller. Set up proper RBAC and CRDs. Create HelmChart/YAML manifests in k8s/knative/ directory. Configure autoscaling parameters: default scale-to-zero after 60s inactivity, target concurrency of 10 requests per pod, max scale of 100 pods per service.",
        "testStrategy": "Deploy test Knative Service, verify scale-to-zero behavior, test request routing and autoscaling",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Research and select Knative Serving version and networking layer",
            "description": "Evaluate Knative Serving v1.12+ releases and compatible networking solutions (Kourier vs nginx) for optimal serverless workload support",
            "dependencies": [],
            "details": "Research latest stable Knative Serving v1.12.x releases, compare Kourier and nginx ingress controllers for networking layer. Evaluate compatibility with existing infrastructure, performance characteristics, and maintenance overhead. Document recommended versions and configuration approach.\n<info added on 2025-10-28T00:22:14.995Z>\nDecision finalized: adopt Knative Serving v1.15.x and Kourier, with direct YAML manifests (no Helm). For this subtask, create k8s/knative/01-serving-crds.yaml by pinning upstream Knative Serving v1.15.x serving-crds.yaml (exact upstream content, no modifications). Include a header comment with the source tag and checksum to track provenance. Ensure this file is applied first (prefix 01-) and that it contains CRDs for services.serving.knative.dev, revisions.serving.knative.dev, routes.serving.knative.dev, and configurations.serving.knative.dev. Aligns with the manifest structure documented in k8s/knative/KNATIVE_DECISION.md. Verification: confirm CRDs are registered via kubectl api-resources | grep serving.knative.dev and validate no diff against upstream for future upgrades.\n</info added on 2025-10-28T00:22:14.995Z>",
            "status": "done",
            "testStrategy": "Create test matrix comparing networking solutions with basic Knative Service deployments"
          },
          {
            "id": 2,
            "title": "Create Helm chart or YAML manifests for Knative CRDs",
            "description": "Generate deployment manifests for Knative Serving Custom Resource Definitions and core resources in k8s/knative/ directory",
            "dependencies": [
              1
            ],
            "details": "Create structured YAML manifests or Helm chart for Knative CRDs installation. Include all required CustomResourceDefinitions, RBAC configurations, and namespace setup. Organize files in k8s/knative/ directory with proper naming conventions and versioning.",
            "status": "done",
            "testStrategy": "Validate CRD installation with kubectl apply --dry-run and verify resource definitions"
          },
          {
            "id": 3,
            "title": "Configure Knative Serving core components",
            "description": "Deploy and configure Knative Serving controller, webhook, and activator components with proper resource allocation and RBAC",
            "dependencies": [
              2
            ],
            "details": "Install Knative Serving core components using official releases. Configure controller deployment with appropriate resource requests/limits, configure webhook for admission control, and set up activator for scale-from-zero functionality. Ensure proper RBAC permissions for all components.",
            "status": "done",
            "testStrategy": "Verify all Knative components are running and ready, test webhook admission control functionality"
          },
          {
            "id": 4,
            "title": "Set up networking layer with Kourier or nginx",
            "description": "Deploy and configure the selected networking layer (Kourier or nginx) for Knative Service routing and ingress management",
            "dependencies": [
              1,
              3
            ],
            "details": "Install and configure the networking layer selected in subtask 1. Set up proper ingress configuration, configure domain routing for Knative Services, and ensure integration with cluster ingress controller. Configure networking policies and service mesh integration if required.",
            "status": "done",
            "testStrategy": "Deploy test Knative Service and verify external accessibility through networking layer"
          },
          {
            "id": 5,
            "title": "Configure autoscaling parameters and policies",
            "description": "Set up Knative autoscaling configuration with scale-to-zero, concurrency targets, and maximum scale limits",
            "dependencies": [
              3
            ],
            "details": "Configure Knative autoscaling with scale-to-zero after 60s inactivity, target concurrency of 10 requests per pod, and maximum scale of 100 pods per service. Set up ConfigMap for global autoscaling parameters and document annotation-based per-service overrides.",
            "status": "done",
            "testStrategy": "Deploy test services with different autoscaling configurations and validate scaling behavior under load"
          },
          {
            "id": 6,
            "title": "Create validation tests for scale-to-zero behavior",
            "description": "Implement comprehensive tests to validate Knative scale-to-zero functionality, cold start performance, and autoscaling behavior",
            "dependencies": [
              4,
              5
            ],
            "details": "Create test suite to validate scale-to-zero behavior after configured inactivity period, measure cold start latency, test autoscaling under various load patterns, and verify proper cleanup of idle pods. Include integration tests for the complete request flow from external traffic to scaled pods.",
            "status": "done",
            "testStrategy": "Automated test suite with load generation, metrics collection, and behavioral validation of scaling events"
          }
        ]
      },
      {
        "id": 3,
        "title": "Configure NGINX Ingress Controller",
        "description": "Setup NGINX Ingress with LoadBalancer service and Cloudflare IP forwarding",
        "details": "Deploy ingress-nginx/controller v1.9+ via Helm chart. Configure service type LoadBalancer with static IP from task 1. Enable real IP forwarding for Cloudflare with use-forwarded-headers=true and compute-full-forwarded-for=true. Set proper annotations for CF-Connecting-IP header handling. Configure SSL passthrough and proper backends for Knative services.",
        "testStrategy": "Test ingress routing, verify client IP forwarding from Cloudflare, validate SSL termination",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install NGINX Ingress Controller via Helm",
            "description": "Deploy the NGINX Ingress Controller using the official Helm chart with proper configuration for Kubernetes cluster integration",
            "dependencies": [],
            "details": "Add the ingress-nginx Helm repository and install the controller v1.9+ using Helm. Configure the deployment with appropriate resource limits, replica count for high availability, and enable metrics collection. Ensure proper namespace creation and RBAC permissions are set up for the controller to manage ingress resources across the cluster.",
            "status": "done",
            "testStrategy": "Verify controller pods are running and ready, check that ingress class is properly registered, test basic HTTP routing functionality"
          },
          {
            "id": 2,
            "title": "Configure LoadBalancer service with static IP integration",
            "description": "Set up the NGINX Ingress service as LoadBalancer type and integrate with the static IP from task 1",
            "dependencies": [
              1
            ],
            "details": "Modify the NGINX Ingress service configuration to use LoadBalancer type and assign the static IP address allocated in task 1. Configure service annotations for cloud provider integration, set proper ports (80, 443), and ensure the external IP is correctly bound to the service. Include session affinity settings if required.",
            "status": "done",
            "testStrategy": "Verify external IP assignment matches static IP from task 1, test connectivity to LoadBalancer endpoints, validate port forwarding works correctly"
          },
          {
            "id": 3,
            "title": "Set up Cloudflare IP forwarding and real IP handling",
            "description": "Configure NGINX to properly handle Cloudflare proxy headers and forward real client IPs",
            "dependencies": [
              2
            ],
            "details": "Enable use-forwarded-headers=true and compute-full-forwarded-for=true in NGINX configuration. Set up proper handling of CF-Connecting-IP header, configure trusted proxy ranges for Cloudflare IP addresses, and ensure real client IPs are properly logged and passed to backend services. Add configuration for X-Forwarded-For and X-Real-IP headers.",
            "status": "done",
            "testStrategy": "Test client IP forwarding through Cloudflare proxy, verify headers are correctly set in backend services, validate logging shows real client IPs"
          },
          {
            "id": 4,
            "title": "Configure SSL passthrough and backend routing",
            "description": "Set up SSL passthrough capabilities and configure proper backend routing for Knative services",
            "dependencies": [
              3
            ],
            "details": "Enable SSL passthrough in NGINX Ingress for services that handle their own TLS termination. Configure backend protocol settings for HTTP/HTTPS backends, set up proper upstream configuration for Knative services, and ensure routing rules work correctly with service mesh integration. Include configuration for WebSocket support and proper timeout settings.",
            "status": "done",
            "testStrategy": "Test SSL passthrough functionality, verify backend routing to Knative services, validate WebSocket connections and timeout behavior"
          },
          {
            "id": 5,
            "title": "Test ingress functionality with sample services",
            "description": "Deploy test services and validate complete ingress functionality including routing, SSL, and IP forwarding",
            "dependencies": [
              4
            ],
            "details": "Create sample HTTP and HTTPS services to test the complete ingress setup. Deploy test ingress resources with different routing rules, verify SSL termination and passthrough modes work correctly, test Cloudflare IP forwarding end-to-end, and validate that all components integrate properly with Knative services. Include load testing to verify performance.",
            "status": "done",
            "testStrategy": "Deploy multiple test services with different configurations, verify routing works correctly, test SSL functionality, validate client IP forwarding through complete stack"
          }
        ]
      },
      {
        "id": 4,
        "title": "Deploy cert-manager for Automatic TLS",
        "description": "Install cert-manager v1.13+ with Let's Encrypt HTTP-01 challenge support",
        "details": "Install cert-manager using Helm chart v1.13.x with CRD installation. Create ClusterIssuer for Let's Encrypt production and staging environments using HTTP-01 challenge solver. Configure ACME account registration with ops email. Set up proper RBAC for certificate management. Include Certificate CRD templates for automatic cert generation.",
        "testStrategy": "Create test Certificate resource, verify ACME challenge completion, validate TLS certificate issuance and renewal",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install cert-manager CRDs and Helm chart",
            "description": "Install cert-manager v1.13+ using Helm chart with proper CRD installation and RBAC configuration",
            "dependencies": [],
            "details": "Add cert-manager Helm repository and install chart v1.13.x with installCRDs=true. Configure proper namespace (cert-manager), service account, and RBAC permissions for certificate management. Verify all CRDs are installed correctly including Certificate, ClusterIssuer, and Issuer resources.",
            "status": "done",
            "testStrategy": "Verify cert-manager pods are running, check CRDs are installed with kubectl get crd | grep cert-manager"
          },
          {
            "id": 2,
            "title": "Create ClusterIssuer for Let's Encrypt production environment",
            "description": "Configure production ClusterIssuer with Let's Encrypt ACME using HTTP-01 challenge solver",
            "dependencies": [
              1
            ],
            "details": "Create production ClusterIssuer YAML with Let's Encrypt production server URL (https://acme-v02.api.letsencrypt.org/directory). Configure HTTP-01 challenge solver with ingress class. Set up ACME account registration with ops email address. Include proper annotations for challenge resolution.",
            "status": "done",
            "testStrategy": "Verify ClusterIssuer is ready with kubectl get clusterissuer, check ACME account registration in logs"
          },
          {
            "id": 3,
            "title": "Create ClusterIssuer for Let's Encrypt staging environment",
            "description": "Configure staging ClusterIssuer with Let's Encrypt staging ACME server for testing purposes",
            "dependencies": [
              1
            ],
            "details": "Create staging ClusterIssuer YAML with Let's Encrypt staging server URL (https://acme-staging-v02.api.letsencrypt.org/directory). Configure HTTP-01 challenge solver matching production setup. Use same ops email for ACME registration. Include rate limiting considerations for staging environment.",
            "status": "done",
            "testStrategy": "Verify staging ClusterIssuer is ready, confirm different server URL in configuration"
          },
          {
            "id": 4,
            "title": "Test certificate issuance and renewal with sample Certificate resource",
            "description": "Create test Certificate resource to validate ACME challenge completion and TLS certificate issuance",
            "dependencies": [
              2,
              3
            ],
            "details": "Create sample Certificate resource referencing staging ClusterIssuer for testing. Configure test domain with proper DNS resolution. Monitor ACME challenge process including HTTP-01 validation. Verify certificate issuance, storage in Secret, and automatic renewal configuration. Test with both staging and production issuers.",
            "status": "done",
            "testStrategy": "Deploy test Certificate, verify ACME challenge completion, validate TLS certificate in Secret, test certificate renewal timing"
          }
        ]
      },
      {
        "id": 5,
        "title": "Setup ExternalDNS with Cloudflare Provider",
        "description": "Configure ExternalDNS to automatically manage DNS records in Cloudflare",
        "details": "Deploy ExternalDNS v0.14+ with Cloudflare provider. Create Kubernetes Secret with Cloudflare API token (zone:read, dns:edit permissions). Configure sources: service, ingress, knative. Set domain-filter for managed domains, txt-owner-id for record ownership, policy=upsert-only for safety. Include RBAC for reading services/ingresses and managing DNS records.",
        "testStrategy": "Deploy test service with external DNS annotation, verify DNS record creation in Cloudflare, test record cleanup on service deletion",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Cloudflare API token with proper permissions",
            "description": "Generate a Cloudflare API token with zone:read and dns:edit permissions for ExternalDNS integration",
            "dependencies": [],
            "details": "Log into Cloudflare dashboard, navigate to My Profile > API Tokens, create custom token with Zone:Zone:Read and Zone:DNS:Edit permissions. Scope to specific zones if needed. Document token creation process and store securely for Kubernetes Secret creation.",
            "status": "done",
            "testStrategy": "Verify token permissions by testing API calls to list zones and create test DNS record"
          },
          {
            "id": 2,
            "title": "Deploy ExternalDNS with Cloudflare provider configuration",
            "description": "Install ExternalDNS v0.14+ with Cloudflare provider and create Kubernetes Secret with API token",
            "dependencies": [
              1
            ],
            "details": "Create Kubernetes Secret with Cloudflare API token. Deploy ExternalDNS using Helm chart or YAML manifests with cloudflare provider configuration. Set sources to service, ingress, knative. Configure txt-owner-id for record ownership and policy=upsert-only for safety. Place manifests in k8s/external-dns/ directory.",
            "status": "done",
            "testStrategy": "Verify ExternalDNS pod starts successfully and logs show successful Cloudflare API connection"
          },
          {
            "id": 3,
            "title": "Configure RBAC for service and ingress watching",
            "description": "Set up proper Role-Based Access Control for ExternalDNS to read services and ingresses",
            "dependencies": [],
            "details": "Create ServiceAccount, ClusterRole, and ClusterRoleBinding for ExternalDNS. Grant permissions to read services, ingresses, nodes, and endpoints. Include permissions for creating and managing DNS-related ConfigMaps and Events. Follow principle of least privilege.",
            "status": "done",
            "testStrategy": "Verify RBAC permissions by checking ExternalDNS can list services and ingresses without errors"
          },
          {
            "id": 4,
            "title": "Set up domain filtering and ownership policies",
            "description": "Configure domain-filter for managed domains and ownership policies for safe DNS management",
            "dependencies": [
              2
            ],
            "details": "Configure domain-filter to restrict ExternalDNS to specific domains. Set txt-owner-id for record ownership tracking. Configure policy=upsert-only to prevent accidental record deletion. Add txt-prefix for TXT record identification. Include annotation-filter if needed for selective service processing.",
            "status": "done",
            "testStrategy": "Deploy service outside domain-filter and verify no DNS records are created, then test with valid domain"
          },
          {
            "id": 5,
            "title": "Test DNS record creation and cleanup with sample services",
            "description": "Validate ExternalDNS functionality by deploying test services and verifying DNS record lifecycle",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create test Kubernetes service with external-dns.alpha.kubernetes.io/hostname annotation. Deploy sample application and verify DNS record creation in Cloudflare dashboard. Test record updates when service changes. Test cleanup by deleting service and confirming DNS record removal.",
            "status": "done",
            "testStrategy": "Deploy test service with DNS annotation, verify record creation in Cloudflare, test record cleanup on service deletion"
          }
        ]
      },
      {
        "id": 6,
        "title": "Create ClusterKit CLI Foundation",
        "description": "Build Go-based CLI tool with core commands and Kubernetes client integration",
        "details": "Create Go CLI using cobra v1.8+ and client-go v0.28+. Initialize project structure with cmd/, pkg/, internal/ directories. Implement core commands: bootstrap, create, status, delete. Set up Kubernetes client configuration and context management. Include configuration file support for cluster credentials and default settings. Use logrus for structured logging and viper for configuration management.",
        "testStrategy": "Unit tests for CLI commands, integration tests with mock Kubernetes cluster, validate kubectl config integration",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Go project with proper module structure",
            "description": "Set up Go module and create standard directory structure for ClusterKit CLI project",
            "dependencies": [],
            "details": "Create new Go module with 'go mod init github.com/user/clusterkit'. Set up directory structure: cmd/ for CLI commands, pkg/ for public packages, internal/ for private packages. Initialize main.go in cmd/clusterkit/ as entry point. Create README.md and .gitignore with Go-specific patterns. Set Go version to 1.21+ in go.mod.",
            "status": "done",
            "testStrategy": "Verify go mod tidy runs without errors, validate directory structure follows Go conventions"
          },
          {
            "id": 2,
            "title": "Set up Cobra CLI framework with core command structure",
            "description": "Install and configure Cobra v1.8+ to provide CLI framework with root command and subcommand structure",
            "dependencies": [
              1
            ],
            "details": "Install cobra v1.8+ dependency. Create root command in cmd/clusterkit/root.go with basic CLI setup including version, help, and global flags. Initialize subcommand structure for bootstrap, create, status, delete commands in cmd/clusterkit/cmd/ directory. Set up command aliases and help text. Configure CLI completion support.",
            "status": "done",
            "testStrategy": "Test CLI help output, verify command structure with --help flags, validate completion functionality"
          },
          {
            "id": 3,
            "title": "Integrate client-go for Kubernetes API access",
            "description": "Add Kubernetes client-go v0.28+ dependency and set up basic client configuration",
            "dependencies": [
              2
            ],
            "details": "Install client-go v0.28+ and related dependencies. Create pkg/k8s/client.go with functions to initialize Kubernetes clientset from kubeconfig. Implement connection testing and cluster validation. Add error handling for authentication failures and unreachable clusters. Create interfaces for easier testing and mocking.",
            "status": "done",
            "testStrategy": "Unit tests for client initialization, integration tests with mock Kubernetes API server"
          },
          {
            "id": 4,
            "title": "Implement configuration management with Viper",
            "description": "Set up Viper for configuration file management and environment variable support",
            "dependencies": [
              2
            ],
            "details": "Install viper dependency and create pkg/config/config.go for configuration management. Support YAML/JSON config files in ~/.clusterkit/ and current directory. Handle environment variables with CLUSTERKIT_ prefix. Create default configuration structure with cluster settings, logging level, and timeout values. Implement config validation and migration.",
            "status": "done",
            "testStrategy": "Test config file loading, environment variable override, validate default values and error handling"
          },
          {
            "id": 5,
            "title": "Add structured logging with logrus",
            "description": "Configure logrus for structured logging throughout the CLI application",
            "dependencies": [
              4
            ],
            "details": "Install logrus dependency and create pkg/log/logger.go for centralized logging setup. Configure log levels (debug, info, warn, error) with JSON formatting for production. Add contextual logging with fields for commands, cluster info, and operation IDs. Implement log output to file and stdout with rotation. Support verbose/quiet flags.",
            "status": "done",
            "testStrategy": "Verify log output formats, test log level filtering, validate file rotation and context preservation"
          },
          {
            "id": 6,
            "title": "Create kubectl config integration and context management",
            "description": "Implement kubectl configuration loading and Kubernetes context management functionality",
            "dependencies": [
              3,
              5
            ],
            "details": "Create pkg/k8s/config.go to load kubectl config from default locations (~/.kube/config). Implement context switching and validation. Add functions to list available contexts, get current context, and validate cluster connectivity. Support custom kubeconfig paths via flags and environment variables. Handle multi-cluster scenarios.",
            "status": "done",
            "testStrategy": "Test kubeconfig loading from various locations, validate context switching, verify cluster connectivity checks"
          },
          {
            "id": 7,
            "title": "Implement basic CLI commands with placeholder functionality",
            "description": "Create bootstrap, create, status, and delete commands with basic structure and placeholder implementations",
            "dependencies": [
              6
            ],
            "details": "Implement cmd/clusterkit/cmd/bootstrap.go for cluster initialization, cmd/clusterkit/cmd/create.go for resource creation, cmd/clusterkit/cmd/status.go for cluster status, and cmd/clusterkit/cmd/delete.go for resource deletion. Add command flags, argument validation, and help text. Include placeholder implementations that log actions and validate inputs. Ensure commands integrate with logging and configuration systems.",
            "status": "done",
            "testStrategy": "Test each command's help output, validate flag parsing, verify placeholder functionality executes without errors"
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Knative Service Creation",
        "description": "Add CLI functionality to create and manage Knative Services with auto DNS and TLS",
        "details": "Implement 'clusterkit create' command that generates Knative Service manifests with proper resource requests (100m CPU, 128Mi memory), autoscaling annotations (min-scale=0, max-scale=5, target=10), and domain configuration. Integrate with cert-manager for automatic Certificate creation. Support --min-scale flag for always-on services. Include validation for resource specifications and domain format.",
        "testStrategy": "Test service creation with various configurations, verify DNS/TLS automation, validate scaling behavior",
        "priority": "high",
        "dependencies": [
          2,
          4,
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Knative Service manifest generation with proper resource specifications",
            "description": "Create the core functionality to generate Knative Service YAML manifests with standardized resource requests and limits",
            "dependencies": [],
            "details": "Implement manifest generation logic that creates Knative Service specs with 100m CPU and 128Mi memory resource requests. Include proper container configuration, service metadata, and revision template structure. Ensure generated manifests are valid Knative resources that can be applied to cluster.",
            "status": "done",
            "testStrategy": "Unit tests for manifest generation, validation of generated YAML structure, integration tests applying manifests to test cluster"
          },
          {
            "id": 2,
            "title": "Add domain configuration and validation logic",
            "description": "Implement domain parsing, validation, and configuration for Knative Services with proper DNS setup",
            "dependencies": [
              1
            ],
            "details": "Create domain validation functions to check format and availability. Implement logic to configure custom domains in Knative Service specs. Add support for both apex domains and subdomains. Include DNS record validation and conflict detection to prevent domain collisions.",
            "status": "done",
            "testStrategy": "Test domain format validation, verify DNS configuration in manifests, test domain conflict detection with existing services"
          },
          {
            "id": 3,
            "title": "Integrate with cert-manager for automatic Certificate creation",
            "description": "Implement automatic TLS certificate generation and management using cert-manager integration",
            "dependencies": [
              2
            ],
            "details": "Create Certificate resource generation logic that works with cert-manager. Implement automatic certificate provisioning for configured domains. Add support for Let's Encrypt ACME challenges. Include certificate renewal monitoring and error handling for failed certificate issuance.",
            "status": "done",
            "testStrategy": "Test certificate creation for various domains, verify ACME challenge completion, validate certificate renewal process"
          },
          {
            "id": 4,
            "title": "Implement autoscaling annotation management",
            "description": "Add comprehensive autoscaling configuration with proper Knative annotations for scaling behavior",
            "dependencies": [
              1
            ],
            "details": "Implement autoscaling annotation logic with min-scale=0, max-scale=5, and target=10 as defaults. Add support for custom scaling parameters and concurrency targets. Include scale-to-zero configuration and cold start optimization settings. Validate scaling annotation combinations for compatibility.",
            "status": "done",
            "testStrategy": "Test autoscaling behavior under load, verify scale-to-zero functionality, validate custom scaling parameter application"
          },
          {
            "id": 5,
            "title": "Add support for --min-scale flag and validation",
            "description": "Implement CLI flag support for minimum scale configuration with proper validation and always-on service support",
            "dependencies": [
              4
            ],
            "details": "Add --min-scale CLI flag parsing and validation logic. Implement override functionality for default min-scale=0 to support always-on services. Include validation for min-scale values against max-scale limits. Add cost estimation warnings for non-zero min-scale configurations.",
            "status": "done",
            "testStrategy": "Test CLI flag parsing, verify min-scale validation logic, test always-on service behavior with non-zero min-scale"
          },
          {
            "id": 6,
            "title": "Create end-to-end testing for service creation workflow",
            "description": "Implement comprehensive integration tests for the complete service creation process including DNS, TLS, and scaling",
            "dependencies": [
              3,
              5
            ],
            "details": "Create end-to-end test suite that validates complete service creation workflow from CLI command to running service with proper DNS and TLS. Include tests for various configuration combinations, error scenarios, and rollback functionality. Validate service accessibility and scaling behavior in test environment.",
            "status": "done",
            "testStrategy": "End-to-end integration tests, service accessibility validation, DNS/TLS verification, scaling behavior testing under simulated load"
          }
        ]
      },
      {
        "id": 8,
        "title": "Add PostgreSQL StatefulSet Support",
        "description": "Implement in-cluster PostgreSQL deployment with persistent storage and backup capabilities",
        "details": "Create PostgreSQL StatefulSet using postgres:16-alpine image with persistent volume claims. Configure automatic backup using GCP disk snapshots via VolumeSnapshot CRDs. Implement 'clusterkit db create' command to provision database with generated credentials stored in Kubernetes Secrets. Include connection string generation and database initialization scripts. Set resource limits: 100m CPU, 256Mi memory, 10Gi storage default.",
        "testStrategy": "Test database creation, persistence across pod restarts, backup/restore functionality, connection string generation",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PostgreSQL StatefulSet manifest templates with proper resource limits",
            "description": "Design and implement StatefulSet manifest templates for PostgreSQL deployment with postgres:16-alpine image and appropriate resource constraints",
            "dependencies": [],
            "details": "Create YAML templates for PostgreSQL StatefulSet with postgres:16-alpine image. Configure resource limits: 100m CPU, 256Mi memory requests. Set up proper pod anti-affinity rules for high availability. Include environment variables for database configuration, security context for non-root execution, and readiness/liveness probes for health checking.",
            "status": "done",
            "testStrategy": "Validate StatefulSet creation, verify resource limits are applied, test pod scheduling and health checks"
          },
          {
            "id": 2,
            "title": "Implement persistent volume claim configuration",
            "description": "Configure PersistentVolumeClaim templates for PostgreSQL data persistence with proper storage class and access modes",
            "dependencies": [
              1
            ],
            "details": "Create PVC templates with 10Gi default storage size and ReadWriteOnce access mode. Configure storage class for GCP persistent disks with SSD performance. Implement volume mount configuration in StatefulSet for PostgreSQL data directory (/var/lib/postgresql/data). Include proper ownership and permission settings for postgres user.",
            "status": "done",
            "testStrategy": "Test data persistence across pod restarts, verify storage class allocation, validate file permissions and ownership"
          },
          {
            "id": 3,
            "title": "Set up secret generation for database credentials",
            "description": "Implement automatic generation and management of PostgreSQL database credentials stored in Kubernetes Secrets",
            "dependencies": [],
            "details": "Create secure random password generation for PostgreSQL superuser and application user accounts. Store credentials in Kubernetes Secrets with proper labels and annotations. Implement credential rotation capability and secure secret mounting in StatefulSet. Include database name, username, and password fields with base64 encoding.",
            "status": "done",
            "testStrategy": "Verify secret creation with proper credentials, test secret mounting in pods, validate password complexity and uniqueness"
          },
          {
            "id": 4,
            "title": "Configure GCP disk snapshot backup automation",
            "description": "Set up automated backup system using GCP VolumeSnapshot CRDs for PostgreSQL data protection",
            "dependencies": [
              2
            ],
            "details": "Implement VolumeSnapshot resource creation for PostgreSQL PVCs using GCP CSI driver. Configure VolumeSnapshotClass with proper snapshot policies and retention settings. Create CronJob for scheduled snapshots with configurable frequency. Include snapshot verification and cleanup of old snapshots based on retention policy.",
            "status": "done",
            "testStrategy": "Test snapshot creation and restoration, verify backup scheduling, validate cleanup of expired snapshots"
          },
          {
            "id": 5,
            "title": "Implement 'clusterkit db create' command",
            "description": "Develop CLI command to provision PostgreSQL databases with automated resource creation and configuration",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create CLI command that orchestrates StatefulSet, PVC, and Secret creation for PostgreSQL instances. Support command-line flags for database name, storage size, and resource limits. Implement proper error handling and status reporting. Include namespace isolation and resource naming conventions with cluster-wide uniqueness validation.",
            "status": "done",
            "testStrategy": "Test command execution with various parameters, verify resource creation order, validate error handling for conflicts"
          },
          {
            "id": 6,
            "title": "Add connection string generation and validation",
            "description": "Implement connection string generation and database initialization scripts for PostgreSQL instances",
            "dependencies": [
              3,
              5
            ],
            "details": "Generate PostgreSQL connection strings with proper format including host, port, database, username from created secrets. Implement database initialization scripts for schema creation and user privilege setup. Create validation functions for connection testing and health checks. Include support for SSL connections and connection pooling parameters.",
            "status": "done",
            "testStrategy": "Test connection string accuracy, verify database connectivity, validate initialization script execution and user permissions"
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Database Attachment to Apps",
        "description": "Create mechanism to securely connect applications to databases via secrets injection",
        "details": "Implement 'clusterkit db attach' command that injects database connection secrets into application environments. Create helper functions to generate DATABASE_URL format strings (postgresql://user:pass@host:port/db). Support multiple database engines (PostgreSQL, MySQL) with proper connection string formats. Include RBAC for secret reading across namespaces and secret mounting in application pods.",
        "testStrategy": "Test secret injection into applications, verify database connectivity from pods, validate secret rotation",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement secret injection logic for database connections",
            "description": "Create core functionality to inject database connection secrets into application environments with proper secret mounting and environment variable mapping",
            "dependencies": [],
            "details": "Develop secret injection mechanism that can mount database credentials as environment variables in application pods. Implement functions to read secrets from source namespace, transform them into appropriate format, and inject into target application's deployment spec. Handle secret rotation and updates automatically.",
            "status": "done",
            "testStrategy": "Unit tests for secret transformation logic, integration tests for secret mounting in pods, verify environment variables are properly set"
          },
          {
            "id": 2,
            "title": "Create DATABASE_URL generation for PostgreSQL and MySQL formats",
            "description": "Implement helper functions to generate proper DATABASE_URL connection strings for PostgreSQL and MySQL database engines",
            "dependencies": [],
            "details": "Create utility functions that format database connection strings according to standard URL formats: postgresql://user:pass@host:port/db for PostgreSQL and mysql://user:pass@host:port/db for MySQL. Handle special characters in passwords, support SSL parameters, and validate connection string format. Include error handling for malformed credentials.",
            "status": "done",
            "testStrategy": "Unit tests for URL generation with various credential formats, test special character escaping, validate against actual database connections"
          },
          {
            "id": 3,
            "title": "Set up RBAC for cross-namespace secret access",
            "description": "Configure Role-Based Access Control to allow applications to read database secrets from different namespaces securely",
            "dependencies": [],
            "details": "Create RBAC policies including ClusterRole and ClusterRoleBinding resources that grant necessary permissions for reading secrets across namespaces. Implement principle of least privilege by limiting access to only database-related secrets. Create service accounts with appropriate permissions for the attachment process.",
            "status": "done",
            "testStrategy": "Test RBAC permissions work correctly, verify cross-namespace secret access, validate security boundaries are maintained"
          },
          {
            "id": 4,
            "title": "Implement 'clusterkit db attach' command",
            "description": "Create CLI command that orchestrates the database attachment process by combining secret injection, URL generation, and RBAC configuration",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement main CLI command that accepts application name, database name, and optional parameters. Orchestrate the attachment process by validating inputs, setting up RBAC if needed, generating appropriate DATABASE_URL, and injecting secrets into target application. Include proper error handling and rollback capabilities.",
            "status": "done",
            "testStrategy": "End-to-end testing of complete attachment workflow, test error scenarios and rollback, verify command-line interface and help text"
          },
          {
            "id": 5,
            "title": "Add validation and testing for database connectivity",
            "description": "Implement comprehensive validation to ensure database connections work properly after attachment and add automated testing suite",
            "dependencies": [
              4
            ],
            "details": "Create validation functions that test actual database connectivity from application pods using injected credentials. Implement health checks that verify DATABASE_URL format and connection success. Add comprehensive test suite covering multiple database engines, error scenarios, and edge cases like credential rotation.",
            "status": "done",
            "testStrategy": "Integration tests with real databases, test connection validation logic, verify health checks work in various scenarios including network failures"
          }
        ]
      },
      {
        "id": 10,
        "title": "Add Multi-Domain Support",
        "description": "Implement domain management for multiple domains per application",
        "details": "Implement 'clusterkit domain add' command to attach additional domains to existing Knative Services. Update Knative Service spec to handle multiple domains via traffic configuration. Automatically create Certificate resources for each domain. Support both apex domains and subdomains with proper DNS validation. Include domain validation and conflict detection.",
        "testStrategy": "Test multiple domain attachment, verify certificate generation for each domain, validate traffic routing",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement domain validation and conflict detection",
            "description": "Create validation logic to ensure domains are properly formatted, not already in use, and DNS is correctly configured before attachment",
            "dependencies": [],
            "details": "Implement DNS validation using dig/nslookup to verify domain ownership and configuration. Check for existing domain usage across Knative Services to prevent conflicts. Validate domain format (apex vs subdomain) and ensure proper DNS records exist. Create validation middleware that can be reused across domain operations.",
            "status": "done",
            "testStrategy": "Test with valid/invalid domains, verify conflict detection with existing services, validate DNS resolution checks"
          },
          {
            "id": 2,
            "title": "Update Knative Service traffic configuration for multiple domains",
            "description": "Modify Knative Service spec to support multiple domains through traffic routing configuration and external domain mappings",
            "dependencies": [
              1
            ],
            "details": "Update Knative Service manifest generation to include multiple domain mappings in the traffic configuration. Implement DomainMapping resources for additional domains. Ensure proper traffic percentage distribution and routing rules. Update existing service modification logic to handle domain additions without disrupting current traffic.",
            "status": "done",
            "testStrategy": "Test traffic routing to multiple domains, verify domain mapping creation, validate service updates without downtime"
          },
          {
            "id": 3,
            "title": "Integrate automatic Certificate resource creation for additional domains",
            "description": "Extend cert-manager integration to automatically create Certificate resources for each additional domain attached to services",
            "dependencies": [
              2
            ],
            "details": "Modify certificate creation logic to generate Certificate resources for each domain. Ensure proper issuer configuration (Let's Encrypt or custom CA). Handle certificate renewal and validation. Update certificate monitoring to track status of all certificates associated with a service. Include cleanup logic for certificates when domains are removed.",
            "status": "done",
            "testStrategy": "Test certificate generation for multiple domains, verify SSL/TLS termination, validate certificate renewal process"
          },
          {
            "id": 4,
            "title": "Implement 'clusterkit domain add' command with proper error handling",
            "description": "Create the CLI command interface for adding domains to existing services with comprehensive error handling and user feedback",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement command-line interface for 'clusterkit domain add <service-name> <domain>' with proper argument validation. Include progress indicators for domain validation, service updates, and certificate creation. Implement rollback mechanisms on failure. Provide clear error messages for common issues like DNS misconfiguration or certificate generation failures. Include --dry-run flag for validation without changes.",
            "status": "done",
            "testStrategy": "Test command with various scenarios, verify error handling and rollback, validate user experience with progress indicators"
          }
        ]
      },
      {
        "id": 11,
        "title": "Implement Status and Monitoring Commands",
        "description": "Add comprehensive status reporting with cost estimation and resource usage",
        "details": "Implement 'clusterkit status' command showing application health, scaling status, certificate validity, last traffic time, and estimated costs. Integrate with GCP Cloud Monitoring API for resource usage metrics. Calculate cost estimates based on current resource consumption and GKE Autopilot pricing. Include 'clusterkit logs' command for log aggregation from Cloud Logging.",
        "testStrategy": "Test status reporting accuracy, verify cost calculations, validate log retrieval from multiple sources",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement application health status checking",
            "description": "Create functionality to check the health status of deployed applications by querying Kubernetes resources and Knative Service readiness",
            "dependencies": [],
            "details": "Implement health checking by querying Kubernetes API for pod status, readiness probes, and Knative Service conditions. Check deployment status, replica counts, and any error conditions. Create health score calculation based on pod readiness, service availability, and recent error rates.",
            "status": "done",
            "testStrategy": "Test health checking against healthy and unhealthy services, verify accurate status reporting and error detection"
          },
          {
            "id": 2,
            "title": "Integrate with GCP Cloud Monitoring API for metrics",
            "description": "Implement integration with Google Cloud Monitoring API to retrieve resource usage metrics for deployed applications",
            "dependencies": [
              1
            ],
            "details": "Set up Cloud Monitoring API client with proper authentication. Query metrics for CPU usage, memory consumption, request rates, and network traffic. Implement metric aggregation over time windows and handle API rate limits. Store and cache metrics data for cost calculations.",
            "status": "done",
            "testStrategy": "Test API integration with various metric queries, verify data accuracy against actual resource usage, validate rate limiting handling"
          },
          {
            "id": 3,
            "title": "Create cost estimation logic based on resource usage",
            "description": "Develop cost calculation engine using GKE Autopilot pricing model and current resource consumption data",
            "dependencies": [
              2
            ],
            "details": "Implement cost calculation using GKE Autopilot pricing tiers for CPU, memory, and storage. Calculate costs based on actual resource usage from monitoring metrics. Include network egress costs and persistent volume pricing. Support hourly, daily, and monthly cost projections with usage trends.",
            "status": "done",
            "testStrategy": "Test cost calculations against known usage patterns, verify accuracy with actual GCP billing data, validate projection algorithms"
          },
          {
            "id": 4,
            "title": "Implement certificate validity checking",
            "description": "Add functionality to check TLS certificate validity, expiration dates, and certificate status for all domains",
            "dependencies": [
              1
            ],
            "details": "Query cert-manager Certificate resources for status and validity. Check certificate expiration dates and renewal status. Validate certificate chains and issuer information. Include warnings for certificates expiring within 30 days and errors for invalid or expired certificates.",
            "status": "done",
            "testStrategy": "Test certificate validation against valid and expired certificates, verify expiration warnings and renewal status detection"
          },
          {
            "id": 5,
            "title": "Add log aggregation from Cloud Logging",
            "description": "Implement log retrieval and aggregation functionality using Google Cloud Logging API for application logs",
            "dependencies": [],
            "details": "Set up Cloud Logging API client to query application logs by service name, namespace, and time range. Implement log filtering, pagination, and real-time streaming. Support log level filtering (error, warn, info) and search functionality. Include structured log parsing for JSON logs.",
            "status": "done",
            "testStrategy": "Test log retrieval from multiple services, verify filtering and search functionality, validate real-time log streaming"
          },
          {
            "id": 6,
            "title": "Create 'clusterkit status' and 'clusterkit logs' commands",
            "description": "Implement CLI commands that integrate all monitoring functionality into user-friendly status reporting and log viewing interfaces",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create 'clusterkit status' command displaying application health, scaling metrics, certificate status, cost estimates, and last traffic time in formatted output. Implement 'clusterkit logs' command with options for service selection, time ranges, log levels, and follow mode. Include JSON output option and colorized formatting.",
            "status": "done",
            "testStrategy": "Test complete status command output format, verify logs command functionality with various filters, validate user experience and command performance"
          }
        ]
      },
      {
        "id": 12,
        "title": "Add Traditional Deployment Mode",
        "description": "Support non-serverless deployments for always-on applications",
        "details": "Implement --traditional flag for 'clusterkit create' to deploy standard Kubernetes Deployments instead of Knative Services. Support websocket applications and services requiring persistent connections. Configure HorizontalPodAutoscaler for traditional deployments. Include Service and Ingress resource creation with proper annotations for cert-manager and ExternalDNS integration.",
        "testStrategy": "Test traditional deployment creation, verify ingress routing, validate HPA behavior with load testing",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Deployment manifest templates for traditional workloads",
            "description": "Design and implement Kubernetes Deployment manifest templates that support traditional always-on applications with proper resource specifications and configuration options.",
            "dependencies": [],
            "details": "Create template files for Kubernetes Deployment resources with configurable replicas, resource requests/limits, environment variables, and volume mounts. Include support for different application types (web servers, APIs, websocket services). Ensure templates follow Kubernetes best practices with proper labels, selectors, and pod specifications. Add validation for required fields and resource constraints.",
            "status": "done",
            "testStrategy": "Unit tests for template generation, validation tests for manifest structure, integration tests with kubectl apply"
          },
          {
            "id": 2,
            "title": "Implement Service and Ingress resource creation",
            "description": "Build functionality to automatically create Kubernetes Service and Ingress resources for traditional deployments with proper networking configuration.",
            "dependencies": [
              1
            ],
            "details": "Implement Service creation with ClusterIP type for internal communication and LoadBalancer/NodePort options. Create Ingress resources with proper annotations for cert-manager (cert-manager.io/cluster-issuer) and ExternalDNS (external-dns.alpha.kubernetes.io/hostname). Support custom paths, SSL redirect, and backend protocol configuration. Include validation for domain names and port specifications.",
            "status": "done",
            "testStrategy": "Test Service endpoint accessibility, verify Ingress routing rules, validate annotation propagation to cert-manager and ExternalDNS"
          },
          {
            "id": 3,
            "title": "Configure HorizontalPodAutoscaler for traditional deployments",
            "description": "Implement HPA configuration for traditional deployments to enable automatic scaling based on CPU and memory metrics.",
            "dependencies": [
              1
            ],
            "details": "Create HPA manifest templates with configurable min/max replicas, target CPU utilization (default 70%), and memory utilization thresholds. Support custom metrics from Kubernetes metrics server. Include proper resource requests in Deployment templates to enable HPA functionality. Add validation for scaling parameters and metric availability. Configure behavior policies for scale-up/scale-down rates.",
            "status": "done",
            "testStrategy": "Load testing to verify HPA scaling behavior, test metric collection accuracy, validate scaling policies under different load patterns"
          },
          {
            "id": 4,
            "title": "Add --traditional flag support to create command",
            "description": "Extend the clusterkit create command to support --traditional flag that switches from Knative Services to standard Kubernetes Deployments.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Modify the create command CLI interface to accept --traditional flag. Implement conditional logic to choose between Knative Service creation (default) and traditional Deployment creation. Add flag validation and help text. Update command parsing to handle traditional-specific options like --replicas, --hpa-min, --hpa-max. Ensure backward compatibility with existing Knative workflow while adding new deployment path.",
            "status": "done",
            "testStrategy": "CLI testing for flag parsing, integration tests comparing traditional vs Knative deployments, validation of flag combinations and error handling"
          },
          {
            "id": 5,
            "title": "Integrate with existing cert-manager and ExternalDNS automation",
            "description": "Ensure traditional deployments seamlessly integrate with existing cert-manager and ExternalDNS automation for automatic TLS certificates and DNS management.",
            "dependencies": [
              2,
              4
            ],
            "details": "Verify Ingress resources created for traditional deployments include proper annotations for cert-manager Certificate generation (cert-manager.io/cluster-issuer: letsencrypt-prod). Ensure ExternalDNS annotations (external-dns.alpha.kubernetes.io/hostname) are correctly applied for automatic DNS record creation. Test integration with existing ClusterIssuer configuration from Task 4. Validate certificate issuance and DNS propagation for traditional deployments match Knative Service behavior.",
            "status": "done",
            "testStrategy": "End-to-end testing of TLS certificate issuance for traditional deployments, DNS resolution validation, comparison testing with Knative Service automation"
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement Cloudflare Edge Configuration",
        "description": "Configure Cloudflare proxy settings and caching rules for optimal performance",
        "details": "Create Terraform module for Cloudflare configuration including page rules for static asset caching, security rules for basic DDoS protection, and proper cache settings for dynamic applications. Configure CF-Connecting-IP header forwarding and rate limiting rules. Include documentation for DNS proxy configuration (orange cloud) and SSL/TLS settings.",
        "testStrategy": "Test Cloudflare proxy functionality, verify caching behavior, validate security rules and rate limiting",
        "priority": "low",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Terraform module for Cloudflare page rules and caching configuration",
            "description": "Develop a Terraform module that defines Cloudflare page rules for static asset caching and dynamic application cache settings",
            "dependencies": [],
            "details": "Create a reusable Terraform module in terraform/modules/cloudflare-caching/ that configures page rules for static assets (CSS, JS, images) with long cache times, dynamic content with appropriate cache headers, and bypass rules for admin/API endpoints. Include variables for cache TTL settings, edge cache TTL, and browser cache TTL. Configure CF-Connecting-IP header forwarding to preserve real client IPs.",
            "status": "done",
            "testStrategy": "Test page rule application by checking cache headers on different content types, verify static assets are cached properly, validate dynamic content caching behavior"
          },
          {
            "id": 2,
            "title": "Implement security rules and rate limiting via Terraform",
            "description": "Configure Cloudflare security features including DDoS protection, rate limiting, and firewall rules through Terraform",
            "dependencies": [
              1
            ],
            "details": "Extend the Terraform module to include Cloudflare security configurations: rate limiting rules for API endpoints (10 requests per minute per IP), firewall rules for basic DDoS protection, security level settings, and challenge pages for suspicious traffic. Configure bot management settings and create custom rules for known attack patterns. Include variables for rate limiting thresholds and security levels.",
            "status": "done",
            "testStrategy": "Test rate limiting by exceeding configured limits, verify DDoS protection triggers appropriately, validate firewall rules block malicious requests"
          },
          {
            "id": 3,
            "title": "Create documentation for DNS proxy setup and SSL/TLS configuration",
            "description": "Document the process for configuring Cloudflare DNS proxy (orange cloud) and SSL/TLS settings for optimal security and performance",
            "dependencies": [
              1,
              2
            ],
            "details": "Create comprehensive documentation covering DNS proxy configuration steps, SSL/TLS mode selection (Full/Strict recommended), certificate management, and troubleshooting common issues. Include guidance on orange cloud vs gray cloud settings, SSL certificate validation, HSTS configuration, and minimum TLS version settings. Provide examples for different application types and security requirements.",
            "status": "done",
            "testStrategy": "Validate documentation accuracy by following setup steps on test domain, verify SSL/TLS configuration results in A+ SSL rating, test DNS propagation and proxy functionality"
          }
        ]
      },
      {
        "id": 14,
        "title": "Add Bootstrap Command and Automation",
        "description": "Implement complete cluster bootstrap with dependency validation and setup verification",
        "details": "Implement 'clusterkit bootstrap' command that orchestrates full cluster setup: GKE creation, component installation (Knative, ingress, cert-manager, ExternalDNS), and validation. Include preflight checks for GCP permissions, Cloudflare API access, and required APIs. Support dry-run mode for validation. Create setup documentation and troubleshooting guides.",
        "testStrategy": "Test complete bootstrap process, verify all components are properly installed and configured, validate end-to-end functionality",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GCP permissions and APIs preflight checks",
            "description": "Create comprehensive validation for required GCP permissions and enabled APIs before bootstrap",
            "dependencies": [],
            "details": "Implement checks for GCP project permissions (container.admin, compute.admin, iam.serviceAccountUser), validate enabled APIs (container, compute, cloudresourcemanager, iam), check billing account access, and verify service account credentials. Create structured error reporting with remediation suggestions.",
            "status": "done",
            "testStrategy": "Test with various permission scenarios, verify API enablement checks, validate error messages and remediation guidance"
          },
          {
            "id": 2,
            "title": "Add Cloudflare API access validation",
            "description": "Validate Cloudflare API credentials and zone permissions before DNS configuration",
            "dependencies": [],
            "details": "Implement Cloudflare API token validation with required permissions (zone:read, dns:edit), verify zone access for target domains, check rate limits and quota availability. Include token scope validation and domain ownership verification.",
            "status": "done",
            "testStrategy": "Test with valid/invalid tokens, verify zone access checks, validate permission scope detection"
          },
          {
            "id": 3,
            "title": "Create component installation orchestration logic",
            "description": "Implement ordered installation sequence with dependency management for all cluster components",
            "dependencies": [
              1,
              2
            ],
            "details": "Create installation orchestrator that handles GKE cluster creation, Knative installation, ingress controller setup, cert-manager deployment, and ExternalDNS configuration in correct dependency order. Include component health checks and installation verification between steps.",
            "status": "done",
            "testStrategy": "Test installation sequence with various failure scenarios, verify component dependencies and health checks"
          },
          {
            "id": 4,
            "title": "Implement dry-run mode for validation",
            "description": "Add comprehensive dry-run capability to validate configuration without making changes",
            "dependencies": [
              3
            ],
            "details": "Implement dry-run mode that validates all configurations, checks resource quotas, simulates installation steps, and reports potential issues without creating resources. Include cost estimation and resource impact analysis.",
            "status": "done",
            "testStrategy": "Test dry-run accuracy against actual installations, verify no resources are created, validate cost estimates"
          },
          {
            "id": 5,
            "title": "Add progress tracking and error recovery",
            "description": "Implement progress monitoring with automatic error recovery and rollback capabilities",
            "dependencies": [
              3
            ],
            "details": "Create progress tracking system with step-by-step status reporting, implement automatic retry logic for transient failures, add rollback mechanisms for failed installations, and include resume capability for interrupted bootstrap processes.",
            "status": "done",
            "testStrategy": "Test error recovery scenarios, verify rollback functionality, validate resume capability after interruption"
          },
          {
            "id": 6,
            "title": "Create comprehensive validation testing",
            "description": "Implement end-to-end validation suite for complete bootstrap verification",
            "dependencies": [
              4,
              5
            ],
            "details": "Create validation tests for complete cluster functionality including Knative service deployment, TLS certificate generation, DNS record creation, ingress routing, and external connectivity. Include performance benchmarks and security validation.",
            "status": "done",
            "testStrategy": "Run validation suite on fresh clusters, verify all components function correctly, validate security configurations"
          },
          {
            "id": 7,
            "title": "Implement setup documentation generation",
            "description": "Create automated documentation generation for cluster configuration and setup details",
            "dependencies": [
              6
            ],
            "details": "Implement documentation generator that creates cluster setup summary, configuration details, access instructions, and maintenance procedures. Include generated credentials, endpoints, and operational runbooks in markdown format.",
            "status": "done",
            "testStrategy": "Verify documentation accuracy and completeness, test generated instructions with fresh users"
          },
          {
            "id": 8,
            "title": "Add troubleshooting and rollback capabilities",
            "description": "Implement comprehensive troubleshooting tools and rollback mechanisms for failed deployments",
            "dependencies": [
              7
            ],
            "details": "Create troubleshooting command with diagnostic checks, log collection, and common issue resolution. Implement complete rollback functionality that removes all created resources and restores previous state. Include debugging tools for component-specific issues.",
            "status": "done",
            "testStrategy": "Test troubleshooting accuracy for common issues, verify complete rollback functionality, validate diagnostic tools"
          }
        ]
      },
      {
        "id": 15,
        "title": "Create Sample Application and Documentation",
        "description": "Deploy reference application and create comprehensive user documentation",
        "details": "Create sample static site and API application demonstrating ClusterKit features. Build Docker images and publish to GitHub Container Registry. Create comprehensive documentation covering: setup guide, CLI reference, troubleshooting, cost optimization tips, and migration guides. Include Cloudflare configuration instructions and GKE Autopilot best practices. Add example manifests and Terraform configurations.",
        "testStrategy": "Test sample applications deployment, verify documentation accuracy, validate all commands work as documented",
        "priority": "medium",
        "dependencies": [
          7,
          8,
          9,
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create sample static site and API applications",
            "description": "Develop a static frontend application and REST API backend that demonstrate ClusterKit's serverless capabilities and integration features",
            "dependencies": [],
            "details": "Create a sample static site (React/Vue/vanilla HTML) and a REST API (Go/Node.js) that showcases ClusterKit features like auto-scaling, load balancing, and service discovery. The static site should include interactive elements that call the API. Both applications should be designed to run as Knative services and demonstrate scale-to-zero behavior. Include health check endpoints and proper logging.",
            "status": "done",
            "testStrategy": "Test applications locally first, then deploy to ClusterKit cluster and verify auto-scaling behavior, load balancing, and service communication"
          },
          {
            "id": 2,
            "title": "Build and publish Docker images to GitHub Container Registry",
            "description": "Create Dockerfiles for sample applications and set up CI/CD pipeline to build and publish images to GitHub Container Registry",
            "dependencies": [
              1
            ],
            "details": "Create multi-stage Dockerfiles for both static site and API applications optimized for size and security. Set up GitHub Actions workflow to automatically build and push images to GitHub Container Registry (ghcr.io) on code changes. Include proper image tagging strategy with semantic versioning and latest tags. Configure registry authentication and ensure images are publicly accessible for documentation examples.",
            "status": "done",
            "testStrategy": "Verify images build successfully, test image pulls from registry, validate images run correctly in local Docker environment"
          },
          {
            "id": 3,
            "title": "Create comprehensive setup and CLI reference documentation",
            "description": "Write detailed setup guides and complete CLI command reference covering all ClusterKit functionality",
            "dependencies": [],
            "details": "Create documentation covering: complete installation guide from prerequisites to first deployment, step-by-step cluster setup with Terraform, CLI installation and configuration, comprehensive command reference with examples for all ClusterKit CLI commands, configuration file formats and options, authentication and credentials setup. Use markdown format with clear sections, code examples, and troubleshooting tips for common issues.",
            "status": "done",
            "testStrategy": "Follow documentation steps on fresh environment, verify all commands work as documented, test with different OS platforms"
          },
          {
            "id": 4,
            "title": "Develop troubleshooting guides and best practices documentation",
            "description": "Create comprehensive troubleshooting guides, cost optimization tips, migration guides, and operational best practices",
            "dependencies": [],
            "details": "Develop documentation covering: common issues and their solutions, debugging techniques for Knative services, cost optimization strategies for GKE Autopilot, migration guides from other platforms, monitoring and observability best practices, security configuration guidelines, backup and disaster recovery procedures, performance tuning recommendations. Include Cloudflare-specific configuration instructions and GKE Autopilot optimization tips.",
            "status": "done",
            "testStrategy": "Validate troubleshooting steps reproduce and solve actual issues, test cost optimization recommendations, verify migration procedures"
          },
          {
            "id": 5,
            "title": "Create example manifests and validate all documented commands",
            "description": "Develop comprehensive example manifests and Terraform configurations, then validate all documentation through end-to-end testing",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create example Kubernetes manifests for various application types, Terraform configuration examples for different deployment scenarios, sample Knative service definitions, ingress configurations, and monitoring setups. Include examples for common use cases like web applications, APIs, batch jobs, and microservices. Perform comprehensive validation by following all documentation steps, testing every CLI command, and verifying all example configurations work correctly.",
            "status": "done",
            "testStrategy": "Deploy all example manifests to test cluster, execute every documented command and verify expected outcomes, test examples on clean environment following documentation"
          }
        ]
      },
      {
        "id": 16,
        "title": "Complete Bootstrap Component Installation Implementation",
        "description": "Implement all 17 TODO stub methods in the bootstrap components to enable actual component installation, uninstallation, and health checking functionality.",
        "details": "The bootstrap orchestrator is well-designed but calls empty stub functions in cli/pkg/bootstrap/components/components.go, preventing any actual installation. This task involves implementing core functionality:\n\n**1. Terraform Component (lines 34-43):**\n- Implement Apply() method using os/exec to run `terraform apply` in terraform/ directory with proper variable passing (project_id, region, cluster_name)\n- Implement Destroy() method using `terraform destroy` with confirmation prompts\n- Add proper error handling, timeout management (10min), and output parsing\n\n**2. Cluster Health Checker (lines 62-66):**\n- Implement Check() method using k8s.io/client-go to verify cluster connectivity\n- Check node readiness, control plane health, and essential system pods\n- Validate cluster version and Autopilot configuration\n\n**3. Knative Component (lines 82-101):**\n- Implement Install() using kubectl apply with manifests from k8s/knative/ directory\n- Implement Uninstall() with proper cleanup of CRDs and resources\n- Implement HealthCheck() to verify knative-serving namespace pods are ready\n- Implement ConfigureDomain() to update config-domain ConfigMap\n\n**4. Ingress Component (lines 118-131):**\n- Implement Install() using helm install nginx-ingress with values from k8s/nginx-ingress/values.yaml\n- Implement Uninstall() using helm uninstall with proper cleanup\n- Implement HealthCheck() to verify nginx-ingress pods ready and LoadBalancer IP assigned\n\n**5. CertManager Component (lines 148-162):**\n- Implement Install() using helm install cert-manager and apply ClusterIssuer manifests from k8s/cert-manager/\n- Implement Uninstall() with proper CRD cleanup sequence\n- Implement HealthCheck() to verify cert-manager pods ready and webhook functional\n\n**6. ExternalDNS Component (lines 180-194):**\n- Implement Install() using kubectl apply with ExternalDNS deployment and Cloudflare secret from k8s/external-dns/\n- Implement Uninstall() with proper secret cleanup\n- Implement HealthCheck() to verify ExternalDNS pod ready and Cloudflare API connectivity\n\n**Technical Requirements:**\n- Use existing k8s.io/client-go v0.28.4 for Kubernetes operations\n- Use os/exec for terraform and helm command execution\n- Add context.WithTimeout for all operations (5min per component)\n- Implement proper error wrapping with component context\n- Ensure idempotency - operations can be run multiple times safely\n- Add structured logging using existing logger\n- Support dry-run mode detection from orchestrator\n- Use existing kubeconfig and context configuration\n\n**Integration Points:**\n- Must work seamlessly with existing orchestrator.go retry and progress logic\n- Health checks called after successful installation for validation\n- Uninstall methods used in rollback scenarios\n- Component constructors already defined and used by orchestrator",
        "testStrategy": "Create comprehensive test suite covering: 1) Unit tests for each component method with mocked kubectl/helm/terraform commands, 2) Integration tests running bootstrap in test GKE cluster verifying all components install successfully, 3) Health check validation tests ensuring accurate status reporting, 4) Rollback tests verifying proper cleanup in failure scenarios, 5) Dry-run mode tests ensuring no actual changes occur, 6) End-to-end bootstrap test validating complete workflow from Terraform to validation, 7) Test component idempotency by running installation multiple times, 8) Verify all 17 TODO comments are resolved and replaced with working implementations",
        "status": "done",
        "dependencies": [
          1,
          2,
          4,
          5
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Terraform Component Apply and Destroy Methods",
            "description": "Implement the Apply() and Destroy() methods for TerraformComponent using os/exec to execute terraform commands in the terraform/ directory",
            "dependencies": [],
            "details": "Implement Apply() method to run 'terraform apply' with auto-approve flag, passing project_id, region, and cluster_name variables via -var flags. Add timeout context (10 minutes), proper error handling, and output parsing. Implement Destroy() method to run 'terraform destroy' with auto-approve flag and same variable passing. Both methods should change directory to terraform/ before execution and use structured logging for output.",
            "status": "done",
            "testStrategy": "Unit tests with mocked os/exec commands to verify correct terraform command construction and variable passing. Integration tests running actual terraform commands in isolated test environment."
          },
          {
            "id": 2,
            "title": "Implement Cluster Health Checker with Kubernetes Client",
            "description": "Implement the Check() method for ClusterHealthChecker using k8s.io/client-go to verify GKE cluster health and readiness",
            "dependencies": [],
            "details": "Use k8s.io/client-go v0.28.4 to connect to the cluster and verify: node readiness status, control plane health via API server connectivity, essential system pods in kube-system namespace (kube-dns, metrics-server), cluster version validation, and Autopilot node pool configuration. Include timeout context (5 minutes) and proper error wrapping with cluster context information.",
            "status": "done",
            "testStrategy": "Unit tests with fake Kubernetes clientset to simulate various cluster health scenarios. Integration tests against real GKE cluster to verify accurate health reporting."
          },
          {
            "id": 3,
            "title": "Implement Knative Component Installation and Management",
            "description": "Implement Install(), Uninstall(), HealthCheck(), and ConfigureDomain() methods for KnativeComponent using kubectl commands and Kubernetes client",
            "dependencies": [],
            "details": "Install() should apply manifests from k8s/knative/ directory using kubectl apply with proper namespace creation. Uninstall() should remove all Knative resources including CRDs with proper cleanup sequence. HealthCheck() should verify knative-serving namespace pods are ready and serving controller is functional. ConfigureDomain() should update config-domain ConfigMap in knative-serving namespace. Use 5-minute timeout contexts and structured logging.",
            "status": "done",
            "testStrategy": "Unit tests with mocked kubectl commands and Kubernetes client operations. Integration tests installing Knative in test cluster and verifying all components are functional."
          },
          {
            "id": 4,
            "title": "Implement Ingress Component with Helm Operations",
            "description": "Implement Install(), Uninstall(), and HealthCheck() methods for IngressComponent using helm commands to manage nginx-ingress controller",
            "dependencies": [],
            "details": "Install() should use 'helm install nginx-ingress' with values from k8s/nginx-ingress/values.yaml, creating ingress-nginx namespace if needed. Uninstall() should use 'helm uninstall nginx-ingress' with proper cleanup of LoadBalancer services. HealthCheck() should verify nginx-ingress pods are ready in ingress-nginx namespace and LoadBalancer service has external IP assigned. Include 5-minute timeout contexts and idempotency checks.",
            "status": "done",
            "testStrategy": "Unit tests with mocked helm commands to verify correct installation parameters. Integration tests deploying nginx-ingress in test cluster and validating LoadBalancer functionality."
          },
          {
            "id": 5,
            "title": "Implement CertManager and ExternalDNS Components with Complete Lifecycle Management",
            "description": "Implement all methods for CertManagerComponent and ExternalDNSComponent including installation, uninstallation, and health checking",
            "dependencies": [],
            "details": "CertManager: Install() using 'helm install cert-manager' and apply ClusterIssuer manifests from k8s/cert-manager/. Uninstall() with proper CRD cleanup sequence. HealthCheck() verifying cert-manager pods ready and webhook functional. ExternalDNS: Install() applying deployment.yaml and creating Cloudflare secret from k8s/external-dns/. Uninstall() with secret cleanup. HealthCheck() verifying ExternalDNS pod ready and Cloudflare API connectivity. Use 5-minute timeouts and proper error context wrapping.",
            "status": "done",
            "testStrategy": "Unit tests with mocked helm and kubectl commands for both components. Integration tests installing cert-manager and ExternalDNS in test cluster, verifying certificate issuance and DNS record management."
          }
        ]
      },
      {
        "id": 17,
        "title": "Add kubectl Integration to CLI Commands with Apply and Status Tracking",
        "description": "Enhance CLI create, db, and domain commands to actually deploy resources to Kubernetes cluster instead of just generating YAML manifests",
        "details": "Implement kubectl apply functionality across all CLI commands using k8s.io/client-go v0.28.4 dynamic client. Add --apply flag (default: false) to maintain backward compatibility with existing YAML-only output. Key implementation components:\n\n1. **Enhanced Create Command (cli/cmd/clusterkit/cmd/create.go):**\n   - Add --apply and --wait flags\n   - Integrate dynamic client to apply generated Knative Service and Ingress manifests\n   - Add deployment status polling with timeout (5 minutes default)\n   - Display pod readiness and service URL when available\n   - Implement automatic rollback on deployment failure\n\n2. **New Apply Package (cli/pkg/apply/):**\n   - Create ApplyClient using dynamic.NewForConfig()\n   - Implement ApplyManifest() for arbitrary YAML resources\n   - Add WaitForDeployment() with status polling\n   - Implement RollbackOnFailure() for cleanup\n   - Support --kubeconfig and --context flags\n\n3. **Connection Validation (cli/pkg/k8s/client.go):**\n   - Extend existing TestConnection() to validate cluster permissions\n   - Add ValidateApplyPermissions() to check RBAC for create/update/delete\n   - Implement GetClusterContext() for current context validation\n   - Add helpful error messages for common issues (expired tokens, network)\n\n4. **Status Tracking System:**\n   - Poll Knative Service status using typed clients\n   - Monitor Deployment/StatefulSet rollout status\n   - Track Ingress ready conditions and certificate issuance\n   - Display real-time progress with spinner/progress bars\n   - Get and display service URLs from Ingress/LoadBalancer\n\n5. **Rollback Implementation:**\n   - Track applied resources during deployment\n   - On failure, delete resources in reverse order\n   - Add --no-rollback flag for debugging failed deployments\n   - Preserve error logs and state for troubleshooting\n\n6. **Extended Command Support:**\n   - db create: Apply StatefulSet, Service, and PVC manifests\n   - domain add: Apply Ingress and Certificate manifests\n   - Consistent --apply flag across all commands\n   - Traditional deployment: Apply Deployment, Service, Ingress, HPA\n\nTechnical implementation uses existing k8s.io/client-go v0.28.4 with:\n- Dynamic client for applying arbitrary manifests\n- Typed clients for status polling (apps/v1, core/v1)\n- Server-side apply for better conflict resolution\n- Context cancellation for timeout handling\n- Structured error handling with actionable messages",
        "testStrategy": "Create comprehensive integration tests: 1) Test create command with --apply deploys actual Knative Service and becomes accessible via HTTPS, 2) Verify deployment status polling shows accurate progress and completion, 3) Test rollback functionality by simulating deployment failures, 4) Validate connection validation catches common issues (expired creds, network problems), 5) Test db create --apply actually provisions PostgreSQL StatefulSet with persistent storage, 6) Verify domain add --apply creates working Ingress with TLS certificate, 7) Test --wait flag properly waits for pod readiness and service availability, 8) Validate backward compatibility - commands without --apply still output YAML only, 9) Test with different kubeconfig contexts and cluster configurations, 10) Verify proper cleanup on partial deployment failures",
        "status": "cancelled",
        "dependencies": [
          6,
          7
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Apply Package with Dynamic Client Integration",
            "description": "Implement a new apply package (cli/pkg/apply/) with dynamic.NewForConfig() client for applying arbitrary YAML manifests to Kubernetes clusters",
            "dependencies": [],
            "details": "Create cli/pkg/apply/client.go with ApplyClient struct using k8s.io/client-go/dynamic. Implement ApplyManifest() function for server-side apply, WaitForDeployment() for status polling with configurable timeout, and RollbackOnFailure() for cleanup. Support --kubeconfig and --context flags through existing k8s client configuration. Use context cancellation for timeout handling and structured error messages for common failures like network issues or expired tokens.",
            "status": "done",
            "testStrategy": "Unit tests for apply client creation, mock dynamic client for testing ApplyManifest functionality, integration tests with actual cluster for full workflow validation"
          },
          {
            "id": 2,
            "title": "Enhance Create Command with Apply and Wait Flags",
            "description": "Add --apply and --wait flags to create command in cli/cmd/clusterkit/cmd/create.go and integrate with dynamic client to deploy generated manifests",
            "dependencies": [
              1
            ],
            "details": "Modify createKnativeService() and createTraditionalDeployment() functions to check --apply flag. When enabled, use the new ApplyClient to deploy generated Knative Service, Ingress, and other manifests instead of just printing YAML. Add deployment status polling with 5-minute default timeout using --wait flag. Display pod readiness status and service URLs when available. Maintain backward compatibility with existing YAML-only output as default behavior.",
            "status": "done",
            "testStrategy": "Integration tests deploying actual Knative Services and traditional deployments, verify status polling accuracy, test rollback on deployment failure scenarios"
          },
          {
            "id": 3,
            "title": "Extend K8s Client with Permission Validation",
            "description": "Enhance existing cli/pkg/k8s/client.go with RBAC permission validation and cluster context validation functions",
            "dependencies": [],
            "details": "Extend the existing TestConnection() method to include cluster permission validation. Add ValidateApplyPermissions() function to check RBAC permissions for create, update, and delete operations on required resource types (services, deployments, ingresses, certificates). Implement GetClusterContext() to validate current context and provide helpful error messages for common issues like expired tokens, network connectivity problems, and insufficient permissions.",
            "status": "pending",
            "testStrategy": "Unit tests for permission checking logic, integration tests with different RBAC configurations, validate error messages for common failure scenarios"
          },
          {
            "id": 4,
            "title": "Implement Status Tracking System for Deployments",
            "description": "Create comprehensive status tracking system that monitors Knative Services, Deployments, and Ingress resources using typed Kubernetes clients",
            "dependencies": [
              1
            ],
            "details": "Implement status polling using typed clients (apps/v1, core/v1) for different resource types. For Knative Services, monitor serving.knative.dev/v1 status conditions. For traditional deployments, track Deployment rollout status and pod readiness. For Ingress resources, monitor ready conditions and certificate issuance status. Display real-time progress with appropriate indicators and extract service URLs from Ingress/LoadBalancer status. Use structured logging for status updates and implement configurable polling intervals.",
            "status": "pending",
            "testStrategy": "End-to-end tests tracking deployment lifecycle from creation to ready state, verify accurate status reporting for different resource types, test timeout handling"
          },
          {
            "id": 5,
            "title": "Add Apply Integration to DB and Domain Commands",
            "description": "Integrate --apply flag support into db create and domain add commands to deploy StatefulSets, Services, and Ingress manifests directly to cluster",
            "dependencies": [
              1,
              2
            ],
            "details": "Modify runDBCreate() in cli/cmd/clusterkit/cmd/db.go to support --apply flag for deploying StatefulSet, Service, and Secret manifests for PostgreSQL databases. Update runDomainAdd() in cli/cmd/clusterkit/cmd/domain.go to apply Certificate and Ingress manifests when --apply flag is used. Ensure consistent flag behavior across all commands and provide status feedback during deployment. Include validation of cluster connectivity before attempting to apply resources.",
            "status": "pending",
            "testStrategy": "Integration tests creating actual databases and domain configurations, verify all generated manifests are applied correctly, test error handling for resource conflicts"
          }
        ]
      },
      {
        "id": 18,
        "title": "Add Comprehensive Test Coverage and CI",
        "description": "Introduce unit, integration, and optional E2E test suites for the CLI, manifest generators, bootstrap components, and preflight checks, plus a CI workflow to run tests and report coverage.",
        "details": "Codebase analysis summary and alignment:\n- Manifest generation exists in: `cli/pkg/knative/service.go` (ServiceConfig.GenerateService, Validate, ToYAMLString), `cli/pkg/knative/ingress.go` (IngressConfig.GenerateIngress, IngressToYAML/String), `cli/pkg/deployment/deployment.go` (GenerateDeployment/Service/Ingress/HPA), and `cli/pkg/database/postgres.go` (GenerateStatefulSet/Service/Secret/GetConnectionURL).\n- Bootstrap components are implemented in `cli/pkg/bootstrap/components/components.go` and use `os/exec` and client-go; health checks query Kubernetes via client-go.\n- Preflight checkers are implemented in `cli/pkg/preflight/gcp.go` and `cli/pkg/preflight/cloudflare.go` using Google and Cloudflare SDKs.\n- No tests currently exist; no MySQL implementation is present.\n\nImplementation plan:\n1) Add test dependencies and helpers\n- Add `github.com/stretchr/testify` to `cli/go.mod` for assertions and require.\n- Add `cli/test/testutil/` with utilities:\n  - `execstub.go`: a CommandRunner stub interface with a fake that records calls; default backed by `exec.CommandContext`.\n  - `k8sfake.go`: helpers to create `kubernetes.Interface` fake clientsets with seeded objects.\n- Add Makefile targets in `cli/Makefile`: `test`, `test-integration`, `test-e2e`, `coverage`.\n\n2) Unit tests: manifest generation (High)\n- `cli/pkg/knative/service_test.go`:\n  - Test `NewServiceConfig` defaults and `Validate` rejects bad inputs (empty name/image, negative min-scale, min>max, invalid quantities).\n  - Test `GenerateService` sets TypeMeta (APIVersion `serving.knative.dev/v1`, Kind `Service`), labels, autoscaling annotations (min/max/target), and `ContainerConcurrency` equals `Concurrency`.\n  - Test `ToYAMLString` round-trips to a struct via `yaml.Unmarshal` and matches name/namespace.\n- `cli/pkg/knative/ingress_test.go`:\n  - Test `NewIngressConfig` defaults (Issuer `letsencrypt-prod`, Class `nginx`).\n  - Test `GenerateIngress` fails with empty domains; success populates TLS with all domains and `cert-manager.io/cluster-issuer` annotation.\n  - Test `IngressToYAMLString` produces parseable YAML with rule per domain and backend service/port 80.\n- `cli/pkg/deployment/deployment_test.go`:\n  - Test `NewDeploymentConfig` defaults and resource limits.\n  - Test `GenerateDeployment` pod template labels, liveness/readiness probes, resources, and replica count math from flags.\n  - Test `GenerateService` selector/ports; `GenerateIngress` annotations (ExternalDNS hostnames aggregation, cert-manager issuer) and per-domain rules; `GenerateHPA` target 70% CPU and min/max replicas.\n- `cli/pkg/database/postgres_test.go`:\n  - Test `NewPostgresConfig` defaults; `GenerateStatefulSet` includes single replica, PVC template with `standard-rwo`, resource requests/limits, env derived from secret keys, and probes.\n  - Test `GenerateService` headless service behavior; `GenerateSecret` contains expected keys and URL; `GetConnectionURL` format and host.\n- Note: MySQL tests requested in brief are deferred until a MySQL implementation exists; add a TODO in `cli/pkg/database/` and file `cli/pkg/database/mysql_test.go` with `t.Skip(\"MySQL component not implemented yet\")` to document intent without failing CI.\n\n3) Unit tests: bootstrap components (High)\nRefactor for testability:\n- Introduce `components.CommandRunner` interface with `Run(ctx context.Context, name string, args ...string) (stdout string, stderr string, err error)` and a default runner using `exec.CommandContext` capturing output. Add a `runner CommandRunner` field to `TerraformComponent`, `KnativeComponent`, `IngressComponent`, `CertManagerComponent`, and `ExternalDNSComponent`. Provide `WithRunner(r CommandRunner)` fluent setter for tests.\n- For Kubernetes access used in HealthCheck methods, add optional `kube kubernetes.Interface` fields and constructors that accept a client (e.g., `NewKnativeComponentWithClient(kube kubernetes.Interface, kubeconfig string)`), defaulting to in-method construction when nil. This enables fake client injection.\nTests:\n- `cli/pkg/bootstrap/components/terraform_test.go`: verify `Apply()` and `Destroy()` invoke runner with expected `terraform init/apply/destroy` arguments and pass variables; assert propagation of runner errors.\n- `cli/pkg/bootstrap/components/knative_test.go`: stub runner to record `kubectl apply -f` calls; assert two applies (CRDs and core) are attempted; with fake clientset, seed `knative-serving` namespace and pods to validate `HealthCheck()` success and failure branches.\n- `cli/pkg/bootstrap/components/ingress_test.go`: verify Helm `repo add`, `repo update`, `install` with namespace and values path `k8s/nginx-ingress/values.yaml`; fake clientset validates namespace/pods checks and LoadBalancer Service IP branch handling.\n- `cli/pkg/bootstrap/components/certmanager_test.go`: verify Helm install with `--set installCRDs=true` and subsequent `kubectl apply` for cluster issuers; fake clientset validates webhook service presence in `HealthCheck()`.\n- `cli/pkg/bootstrap/components/externaldns_test.go`: fake clientset validates namespace and secret creation/update, and pod health; runner verifies `kubectl apply -f k8s/external-dns/deployment.yaml` executed.\nNote: The repos manifest filenames differ from component code in a few places (e.g., Knative CRDs/core and cert-manager issuer filenames). Tests will assert calls are made under the components `manifestsDir` with the filenames used by code. Propose a follow-up task to align filenames.\n\n4) Unit tests: preflight checks (High)\nRefactor for testability:\n- Update `GCPPreflightChecker` to accept optional `opts []option.ClientOption` in constructor and internal helpers so tests can inject `option.WithHTTPClient` against `httptest.Server` mocks or use fake services.\n- Update `CloudflarePreflightChecker` to accept an overridable API client constructor (e.g., functional option to set `newAPI func(token string) (*cloudflare.API, error)`), allowing tests to stub `UserDetails`, `VerifyAPIToken`, and zone listing.\nTests:\n- `cli/pkg/preflight/gcp_test.go`: mock credentials failure, project access failure, and specific missing API/permission cases; validate `CheckResult.Remediation` contains correct guidance and `GCPPreflightResults.FailedCount` increments.\n- `cli/pkg/preflight/cloudflare_test.go`: simulate missing token, inactive token, permission errors on listing zones, and success path; validate `Zones` collected and failure messages.\n\n5) Integration tests with kind (Medium)\n- Add `test/integration/kind_test.go` guarded by `//go:build integration` and environment variable `RUN_INTEGRATION=1`:\n  - Setup: install Kind (CI step) and create a cluster; obtain kubeconfig path.\n  - Run bootstrap orchestrator with `SkipTerraform=true`, `SkipExternalDNS=true` by default; verify steps succeed using `bootstrap.NewOrchestrator` and `o.Run()`; then create a minimal app manifest via `knative.NewServiceConfig` and validate K8s objects exist using `client-go`.\n  - If `CLUSTERKIT_ENABLE_APPLY=1` and Task 17 is complete, also run `clusterkit create --apply --wait` via `exec.Command` against the kind cluster and assert service becomes Ready via K8s API.\n\n6) E2E tests (Medium, optional)\n- Add `test/e2e/e2e_test.go` guarded by `//go:build e2e` and `RUN_E2E=1` to run a full bootstrap on Kind and deploy sample app from `examples/`.\n- Use cert-manager with self-signed or staging issuers; limit DNS tests to Knative `config-domain` checks; skip Cloudflare-dependent verifications in CI.\n\n7) CI pipeline (High)\n- Add `.github/workflows/test.yml` that:\n  - Triggers on PR and push; uses `actions/setup-go@v4` with Go 1.21.\n  - Caches Go modules.\n  - Runs `golangci-lint` (add a minimal `.golangci.yml` if missing; checks: govet, gofmt, gofumpt if configured, errcheck). Fallback to `go vet ./...` if linter not configured.\n  - Runs unit tests with `go test ./... -count=1 -race -coverprofile=coverage.out -covermode=atomic`.\n  - Publishes `coverage.out` as an artifact and posts coverage summary.\n  - Optionally spins up Kind using `kind create cluster` and runs `go test -tags=integration ./test/integration -v` when label `integration` is present or nightly cron.\n  - Builds the CLI binary (`go build ./cli/cmd/clusterkit`).\n\nCoverage goals and notes:\n- Focus unit tests on manifest generators, bootstrap logic branches, and preflight error paths to exceed 70% coverage quickly; stretch to 80% by covering domain utilities in `cli/pkg/knative/domain.go` and k8s client wrappers in `cli/pkg/k8s/`.\n- Document MySQL tests as pending: they will be added when a MySQL component exists.\n\nRepository touchpoints (files to add/modify):\n- New test files: `cli/pkg/knative/service_test.go`, `cli/pkg/knative/ingress_test.go`, `cli/pkg/deployment/deployment_test.go`, `cli/pkg/database/postgres_test.go`, `cli/pkg/database/mysql_test.go` (skipped), `cli/pkg/bootstrap/components/*_test.go`, `cli/pkg/preflight/*_test.go`, `test/integration/kind_test.go`, `test/e2e/e2e_test.go`.\n- Small refactors for DI: `cli/pkg/bootstrap/components/components.go`, `cli/pkg/preflight/gcp.go`, `cli/pkg/preflight/cloudflare.go` to support injection of runners/clients.\n- CI: `.github/workflows/test.yml`; optional `.golangci.yml` if not present.\n- Makefile: add `test`, `test-integration`, `coverage` targets and `tools` install for `golangci-lint`.\n",
        "testStrategy": "Unit tests:\n- Run `go test ./... -count=1` to ensure all unit tests pass locally.\n- Validate manifest tests by unmarshalling YAML and checking fields (APIVersions, Kinds, labels, annotations, resources, TLS blocks, rules).\n- Bootstrap component tests assert command invocations (args and order) via fake runner and simulate failures to verify error propagation; health checks use fake clientsets with seeded namespaces/pods/services to cover success and failure branches.\n- Preflight tests mock SDKs/HTTP to assert each check results `Passed`, `Message`, and `Remediation` values; verify `FailedCount` and `AllPassed` aggregation.\n\nIntegration tests:\n- In CI with Kind enabled, run `go test -tags=integration ./test/integration -v` after `kind create cluster` and `KUBECONFIG=$(kind get kubeconfig-path)`; assert bootstrap orchestrator completes (skipping Terraform/ExternalDNS by flags) and that required namespaces and controller pods exist.\n- If `CLUSTERKIT_ENABLE_APPLY=1`, run a create/apply flow and assert Knative Service reaches Ready and Ingress exists; otherwise skip with t.Skip.\n\nE2E tests (optional):\n- When `RUN_E2E=1`, run end-to-end bootstrap and deploy example app; assert Knative domain config and cert-manager webhook service existence, and basic HTTP 200 from ClusterIP using port-forward.\n\nCI verification:\n- Workflow runs unit tests on every PR; integration tests run on nightly or labeled PRs. Ensure coverage artifact `coverage.out` is uploaded. Gate merges on unit tests/lint passing and coverage >= 70%.",
        "status": "cancelled",
        "dependencies": [
          2,
          7,
          14,
          16
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Create Comprehensive Project Documentation Suite",
        "description": "Create a cohesive documentation set with a root README and a docs/ folder that consolidates existing scattered docs into clear getting started, architecture, CLI reference, operations, troubleshooting, and development guides aligned to the current codebase and examples.",
        "details": "Scope and deliverables:\n\n1) Root README.md (project overview + quick start)\n- Create `README.md` at repo root with:\n  - Value proposition and problem statement (serverless on GKE Autopilot with scale-to-zero, low cost).\n  - Architecture overview diagram (Mermaid) reflecting repo components:\n    ```mermaid\n    graph TD\n      A[Users/CI] -->|HTTPS| CF[Cloudflare]\n      CF --> LB[GCP Static IP / NGINX Ingress]\n      LB --> Kourier[Kourier Gateway]\n      Kourier --> KSVC[Knative Services]\n      KSVC --> Pods[Workloads]\n      KSVC --> PG[(PostgreSQL StatefulSets)]\n      CF -. DNS Sync .-> EDNS[ExternalDNS]\n      CM[cert-manager] --> TLS[Certificates]\n    ```\n  - 5-minute quick start: link to docs/getting-started.md and include a concise inline version using `clusterkit bootstrap` then `clusterkit create` based on `cli/README.md` examples.\n  - Prerequisites (versions): Terraform >= 1.6.0 (from `terraform/README.md`), kubectl 1.28+, gcloud latest, Go 1.21+ (from `cli/go.mod`), Cloudflare account.\n  - Installation from source using Go (reuse `cli/README.md` flow): `cd cli && go build -o clusterkit ./cmd/clusterkit` and verify with `clusterkit version`.\n  - Basic usage examples for `create`, `status`, `db create/attach`, `delete` (lift from `cli/README.md`).\n  - Links to detailed docs in `docs/`.\n  - Contributing + development pointers (link to `docs/development.md`).\n  - License section: state MIT (consistent with `cli/README.md`), and note to add/keep a LICENSE file if missing.\n\n2) Getting Started Guide (docs/getting-started.md)\n- Create `docs/getting-started.md` with:\n  - Detailed prerequisites and versions: Terraform >= 1.6.0 (`terraform/README.md`), kubectl compatible with cluster, Go 1.21 (`cli/go.mod`), gcloud init, Cloudflare API token.\n  - GCP setup: billing, APIs, and Terraform steps reusing `terraform/README.md` (copy quick steps and required IAM roles, outputs usage, plus `gcloud container clusters get-credentials`).\n  - Cloudflare setup: token scopes and DNS config pulled from `k8s/external-dns/CLOUDFLARE_TOKEN_SETUP.md` and `k8s/external-dns/README.md`.\n  - Install ClusterKit CLI: reuse `cli/README.md` commands; document config paths from `cli/README.md` and `cli/pkg/config/config.go` default locations.\n  - Bootstrap flow: `clusterkit bootstrap --project-id ... --region ... --domain ... --cloudflare-token ...` explaining flags.\n  - First app deployment: `clusterkit create` using `cli/pkg/knative/service.go` defaults (cpu=100m, mem=128Mi requests; min-scale=0; target=10) and domain validation rules in `cli/pkg/knative/domain.go`.\n  - Verify: `clusterkit status`, wait for DNS and TLS (cert-manager) and test HTTPS.\n  - Troubleshooting pointers linking to `docs/troubleshooting.md`.\n\n3) Architecture Documentation (docs/architecture.md)\n- Create `docs/architecture.md` with:\n  - System and data flow diagrams (Mermaid) mapping components to code and infra.\n  - Component relationships with code anchors:\n    - Bootstrap orchestration: `cli/pkg/bootstrap/orchestrator.go` (step execution, health checks) and `cli/pkg/bootstrap/components/*` for install logic.\n    - Knative manifest generation: `cli/pkg/knative/service.go`, `cli/pkg/knative/ingress.go`, `cli/pkg/knative/yaml.go`.\n    - Traditional deployments: `cli/pkg/deployment/deployment.go` (Deployment/Service/Ingress/HPA).\n    - Database: `cli/pkg/database/postgres.go` (StatefulSet, Service, Secret, GetConnectionURL()).\n    - Kubernetes client wrapper: `cli/pkg/k8s/client.go`.\n    - IaC layout: `terraform/` modules (gke, networking, iam, cloudflare), `terraform/providers.tf`, `terraform/variables.tf`.\n  - Security model: Workload Identity (Terraform modules), cert-manager issuers (`k8s/cert-manager/*`), RBAC for secrets (noting where to extend for cross-namespace secret access as used by DB attach).\n  - Scalability: Knative autoscaling defaults from `k8s/knative/05-config-autoscaler.yaml` and per-service annotations in `cli/pkg/knative/service.go`.\n\n4) CLI Reference (docs/cli-reference.md)\n- Create a complete command reference using current behavior documented in `cli/README.md` and code:\n  - Commands: `clusterkit bootstrap`, `clusterkit create`, `clusterkit delete`, `clusterkit status`, `clusterkit logs`, `clusterkit db create/attach/list/delete`, and `clusterkit troubleshoot`.\n  - For each: Description, Usage, Flags, Examples, Common issues.\n  - Reflect generated resources and defaults from code:\n    - create (Knative) resources/annotations per `cli/pkg/knative/service.go` (CPU/Memory requests/limits, min/max scale, target concurrency, labels/annotations).\n    - traditional mode: reference `cli/pkg/deployment/deployment.go` outputs (Deployment/Service/Ingress/HPA) and annotations for ExternalDNS/cert-manager.\n    - db create: secret keys and connection URL per `cli/pkg/database/postgres.go`.\n    - bootstrap: step list and health checks per `cli/pkg/bootstrap/orchestrator.go`.\n    - troubleshoot: diagnostics as in `cli/pkg/bootstrap/troubleshoot.go` (components and remediation text patterns).\n  - Note: when applicable, include a future note that `--apply/--wait` flags (Task 17) will enhance behavior but do not block current docs.\n\n5) Operations Guide (docs/operations.md)\n- Consolidate Day 2 tasks using `cli/pkg/bootstrap/docs.go` Operations/Troubleshooting patterns:\n  - Monitoring and status (`clusterkit status`, `clusterkit logs`, `kubectl top`).\n  - Backup/restore (export KSVCS, ingresses, certificates) as in docs generator.\n  - Upgrades: Knative and cert-manager manifests (matching `k8s/knative/README.md` and docs generator snippets).\n  - Security hardening: Cloudflare rate limiting (`terraform/modules/cloudflare`), secret rotation, forcing cert renewals.\n  - Cost optimization: scale-to-zero, min-scale overrides, and GKE Autopilot considerations (reuse from `terraform/README.md` and k8s/knative cost notes).\n\n6) Troubleshooting Guide (docs/troubleshooting.md)\n- Build a comprehensive guide aligned to checks implemented in `cli/pkg/bootstrap/troubleshoot.go`:\n  - Common errors (cluster connectivity, DNS/ExternalDNS issues, TLS/cert-manager, Ingress/LoadBalancer, Knative health).\n  - Component health checks with concrete kubectl and log commands.\n  - Recovery procedures (restart components, force certificate renewal, recreate services) consistent with docs generator outputs.\n  - Debug mode usage (`clusterkit --log-level=debug`).\n\n7) Development Guide (docs/development.md)\n- Document:\n  - Environment setup and Go version (Go 1.21 per `cli/go.mod`).\n  - Building from source and structure (`cli/` modules layout; mention that Cobra commands live under `cmd/clusterkit` per `cli/README.md` and libs under `cli/pkg/*`).\n  - Running tests: `go test ./...` and targeted package testing (e.g., `cli/pkg/knative`).\n  - Code structure overview pointing to major packages listed above.\n  - Contributing workflow: conventional commits, PR checks, style, and how to add/extend commands.\n  - Release process outline (build, tag, and publish binaries or container if applicable).\n\nImplementation notes and alignment with current repo:\n- Reuse and link to existing docs: `cli/README.md` (commands, quick start), `terraform/README.md`, `k8s/*/README.md`, and `examples/README.md` and manifests (`examples/manifests/*.yaml`, `examples/api/*`, `examples/static-site/*`).\n- Normalize terminology: use ClusterKit CLI, GKE Autopilot, Knative Service, Traditional Deployment.\n- Cross-link files using relative paths and ensure paths exist.\n- Add consistent front-matter (H1, summary, prerequisites) and anchors for sections.\n- Prefer Mermaid for diagrams and include ASCII fallbacks where helpful.\n- Ensure root README links to each doc and to examples.\n",
        "testStrategy": "Documentation validation checklist:\n\nGeneral\n- Verify all new files exist and links work: `README.md`, `docs/getting-started.md`, `docs/architecture.md`, `docs/cli-reference.md`, `docs/operations.md`, `docs/troubleshooting.md`, `docs/development.md`.\n- Run `rg -n \"\\(docs/|examples/|terraform/|k8s/|cli/pkg/\\)\" README.md docs/*.md` to ensure referenced paths exist.\n- Open Markdown in a renderer (e.g., VS Code preview) to confirm Mermaid blocks and code fences render correctly.\n\nQuick Start and Getting Started\n- On a clean environment, follow `README.md` quick start and `docs/getting-started.md` end-to-end:\n  - Confirm prerequisites versions: `terraform -v` (>=1.6), `kubectl version --client` (>=1.28), `go version` (>=1.21), `gcloud version`.\n  - Build CLI from `cli/README.md` instructions; run `clusterkit version` and `clusterkit --help` to ensure commands displayed match docs.\n  - Run `clusterkit bootstrap` with a test project and Cloudflare token; confirm step progress aligns with `cli/pkg/bootstrap/orchestrator.go` step list.\n  - Deploy sample app using `clusterkit create`; verify DNS and TLS issue; access HTTPS URL.\n  - Use `clusterkit status` and `clusterkit logs` to validate outputs match documented expectations.\n\nCLI Reference\n- For each command in docs, run `clusterkit <cmd> --help` and confirm flags and descriptions match the documented ones.\n- Confirm behavior-specific details align with code defaults (e.g., autoscaling annotations in `cli/pkg/knative/service.go`, HPA behavior in `cli/pkg/deployment/deployment.go`, DB secret keys and URL format in `cli/pkg/database/postgres.go`).\n\nArchitecture and Operations\n- Cross-check architecture diagrams against actual repos and install scripts under `k8s/knative/*`, `k8s/external-dns/*`, and Terraform modules in `terraform/modules/*`.\n- Execute operations commands (backup/restore, upgrade snippets) in a test cluster to ensure they run without errors.\n\nTroubleshooting\n- Intentionally break common scenarios (wrong Cloudflare token, missing cert-manager, Knative pods not ready) and verify `docs/troubleshooting.md` remedies resolve the issue; compare with remediation text in `cli/pkg/bootstrap/troubleshoot.go`.\n\nAcceptance\n- Have a new teammate follow `README.md` + `docs/getting-started.md` to deploy the sample app within 15 minutes and report any friction or missing steps.\n",
        "status": "done",
        "dependencies": [
          1,
          6,
          7,
          8,
          9,
          11,
          13
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-27T08:24:54.008Z",
      "updated": "2025-11-03T21:59:06.875Z",
      "description": "Tasks for master context"
    }
  }
}